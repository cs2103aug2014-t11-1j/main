//@author: a0116211b



	/**
	 * origin: C:\Users\Jireh\Documents\CS2103T_main\src\gui\controller\AnimationHandler.java
	 */

public class AnimationHandler {

	@FXML
	private AnchorPane tableAnchor;
	@FXML
	private AnchorPane todayAnchor;
	@FXML
	private AnchorPane helperAnchor;
	@FXML
	private AnchorPane tentativeAnchor;
	@FXML
	private AnchorPane timelineAnchor;

	private boolean isFocusTable_;
	private boolean isFocusToday_;
	private boolean isFocusHelper_;
	private boolean isFocusTentative_;
	private boolean isFocusTimeline_;

	private boolean isPlaying;

	TranslateTransition slideInTable_;
	TranslateTransition slideOutTable_;

	TranslateTransition slideInToday_;
	TranslateTransition slideOutToday_;

	TranslateTransition slideInHelper_;
	TranslateTransition slideOutHelper_;	

	TranslateTransition slideInTimeline_;
	TranslateTransition slideOutTimeline_;
	
	TranslateTransition slideInTentative_;
	TranslateTransition slideOutTentative_;

	private static final int NUMBER_OF_VIEWS = 2;
	private static final int TODAY_INDEX = 0;
	private static final int TABLE_INDEX = 1;
	private static final int TIMELINE_INDEX = 2;
	private static final int TENTATIVE_INDEX = 3;
	private static Integer viewIndex;

	private static AnimationHandler ah_ = new AnimationHandler();

	private AnimationHandler(){
	}

	public static AnimationHandler getInstance(){
		return ah_;
	}

	public void initialize(AnchorPane tableAnchor, AnchorPane todayAnchor, AnchorPane helperAnchor){

		viewIndex = TODAY_INDEX;

		TranslateTransition slideOutTableInit = new TranslateTransition(Duration.millis(100), tableAnchor);
		slideOutTableInit.setToX(700);
		slideOutTableInit.play();
		TranslateTransition slideOutTentativeInit = new TranslateTransition(Duration.millis(100), tentativeAnchor);
		slideOutTentativeInit.setToX(700);
		slideOutTentativeInit.play();
		TranslateTransition slideOutTimelineInit = new TranslateTransition(Duration.millis(100), timelineAnchor);
		slideOutTimelineInit.setToX(700);
		slideOutTimelineInit.play();
		TranslateTransition slideOutHelperInit = new TranslateTransition(Duration.millis(100), helperAnchor);
		slideOutHelperInit.setToX(700);
		slideOutHelperInit.play();

		isFocusTable_ = false;
		isFocusHelper_ = false;
		isFocusTentative_ = false;
		isFocusTimeline_ = false;
		isFocusToday_ = true;

		slideInTable_ = new TranslateTransition(Duration.seconds(0.2), tableAnchor);
		slideInTable_.setToX(0);
		slideOutTable_ = new TranslateTransition(Duration.seconds(0.2), tableAnchor);
		slideOutTable_.setToX(700);

		slideInToday_ = new TranslateTransition(Duration.seconds(0.2), todayAnchor);
		slideInToday_.setToX(0);
		slideOutToday_ = new TranslateTransition(Duration.seconds(0.2), todayAnchor);
		slideOutToday_.setToX(700);
		
		slideInTentative_ = new TranslateTransition(Duration.seconds(0.2), tentativeAnchor);
		slideInTentative_.setToX(0);
		slideOutTentative_ = new TranslateTransition(Duration.seconds(0.2), tentativeAnchor);
		slideOutTentative_.setToX(700);

		slideInTimeline_ = new TranslateTransition(Duration.seconds(0.2), timelineAnchor);
		slideInTimeline_.setToX(0);
		slideOutTimeline_ = new TranslateTransition(Duration.seconds(0.2), timelineAnchor);
		slideOutTimeline_.setToX(700);

		slideInHelper_ = new TranslateTransition(Duration.seconds(0.2), helperAnchor);
		slideInHelper_.setToX(0);
		slideOutHelper_ = new TranslateTransition(Duration.seconds(0.2), helperAnchor);
		slideOutHelper_.setToX(700);


		

	}

	public int getViewIndex(){
		return viewIndex;
	}

	public boolean getIsFocusTable(){
		return isFocusTable_;
	}

	public boolean getIsFocusToday(){
		return isFocusToday_;
	}

	public void showTimeline(){
		if(isFocusTable_){
			slideOutTable_.play();
		}
		else{
			slideOutToday_.play();
		}
	}

	public void showTableView(){
		if(isFocusToday_){
			isPlaying = true;

			slideInTable_.play();
			slideOutToday_.play();
			slideOutTimeline_.play();

			isFocusToday_ = false;
			isFocusTable_ = true;
		}

		if(isFocusTimeline_){
			isPlaying = true;

			slideInTable_.play();
			slideOutTimeline_.play();
			slideOutToday_.play();

			isFocusTimeline_ = false;
			isFocusTable_ = true;
		}
		
		if(isFocusTentative_){
			slideInTable_.play();
			slideOutTentative_.play();
			
			isFocusTentative_ = false;
			isFocusTable_ = true;
		}

		viewIndex = TABLE_INDEX;
	}

	public void showTodayView(){
		if(isFocusTable_){
			isPlaying = true;

			slideOutTable_.play();
			slideInToday_.play();
			slideOutTimeline_.play();

			isFocusTable_ = false;
			isFocusToday_ = true;
		}

		if(isFocusTimeline_){
			isPlaying = true;

			slideInToday_.play();
			slideOutTimeline_.play();
			slideOutTable_.play();

			isFocusTimeline_ = false;
			isFocusToday_ = true;
		}
		
		if(isFocusTentative_){
			slideInToday_.play();
			slideOutTentative_.play();
			
			isFocusTentative_ = false;
			isFocusToday_ = true;
		}

		viewIndex = TODAY_INDEX;
	}
	
	public void showTentativeView(){
		if(isFocusToday_){
			slideOutToday_.play();
			slideInTentative_.play();
			
			isFocusToday_ = false;
			isFocusTentative_ = true;
		}
		
		if(isFocusTable_){
			slideOutTable_.play();
			slideInTentative_.play();
			
			isFocusTable_ = false;
			isFocusTentative_ = true;
		}
		
		if(isFocusTimeline_){
			slideOutTimeline_.play();
			slideInTentative_.play();
			
			isFocusTable_ = false;
			isFocusTentative_ = true;
		}
		
		viewIndex = TENTATIVE_INDEX;
	}

	public void showTimelineView() {
		if(isFocusToday_){
			isPlaying = true;

			slideInTimeline_.play();
			slideOutToday_.play();
			slideOutTable_.play();

			isFocusToday_ = false;
			isFocusTimeline_ = true;
		}
		if(isFocusTable_){
			isPlaying = true;

			slideInTimeline_.play();
			slideOutTable_.play();
			slideOutToday_.play();

			isFocusTable_ = false;
			isFocusTimeline_ = true;
		}
		if(isFocusTentative_){
			slideInTimeline_.play();
			slideOutTentative_.play();
			
			isFocusTentative_ = false;
			isFocusTimeline_ = true;
		}

		viewIndex = TIMELINE_INDEX;
	}

	public void displayHelper(){
		if(isFocusToday_){
			slideOutToday_.play();
			slideInHelper_.play();

			isFocusToday_ = false;
			isFocusHelper_ = true;
		}

		if(isFocusTable_){
			slideOutTable_.play();
			slideInHelper_.play();

			isFocusTable_ = false;
			isFocusHelper_ = true;
		}
		
		if(isFocusTentative_){
			slideOutTentative_.play();
			slideInHelper_.play();

			isFocusTentative_ = false;
			isFocusHelper_ = true;
		}

		if(isFocusTimeline_){
			slideOutTimeline_.play();
			slideInHelper_.play();

			isFocusTimeline_ = false;
			isFocusHelper_ = true;
		}
	}

	public void removeHelper(){
		if(isFocusHelper_){
			slideOutHelper_.play();
			slideInTable_.play();

			isFocusTable_ = true;
			isFocusHelper_ = false;
			viewIndex = TABLE_INDEX;
		}
	}

	public void revertView(){
		if(isFocusHelper_){
			slideOutHelper_.play();
			slideInToday_.play();

			isFocusToday_ = true;
			isFocusHelper_ = false;
			viewIndex = TODAY_INDEX;
		}		

	}

	public void animateRight() {
		viewIndex++;
		if(viewIndex > NUMBER_OF_VIEWS - 1){
			viewIndex = NUMBER_OF_VIEWS - 1;
		} else {
			shiftViewToIndex();
		}
	}

	public void animateLeft() {
		viewIndex--;
		if(viewIndex < 0){
			viewIndex = 0;
		} else {
			shiftViewToIndex();
		}
	}

	private void shiftViewToIndex() {

		switch((viewIndex + NUMBER_OF_VIEWS) % NUMBER_OF_VIEWS) {
		case TODAY_INDEX :
			showTodayView();
			break;
		case TABLE_INDEX :
			showTableView();
			break;
//		case TENTATIVE_INDEX :
//			showTentativeView();
//			break;
		case TIMELINE_INDEX :
			showTimelineView();
			break;			
		default :
			System.out.println("lol");
		}		
	}
	
	public void fadeLabel(Label tfOutput){
		FadeTransition fadeTransition
		= new FadeTransition(Duration.millis(3200), tfOutput);
		fadeTransition.setFromValue(1.0);
		fadeTransition.setToValue(0.0);
		fadeTransition.play();
	}

}

	// End of segment: C:\Users\Jireh\Documents\CS2103T_main\src\gui\controller\AnimationHandler.java





	/**
	 * origin: C:\Users\Jireh\Documents\CS2103T_main\src\gui\controller\CommandLineUtility.java
	 */

public class CommandLineUtility {
	
	private Stack<String> previousInput_;
	private Stack<String> forwardInput_;
	
	private TextField commandLine_;
	
	private static CommandLineUtility clu_ = new CommandLineUtility();

	private CommandLineUtility(){
	}

	public static CommandLineUtility getInstance(){
		return clu_;
	}
	
	public void forwardToPrevious(){
		while(!forwardInput_.isEmpty()){
			previousInput_.push(forwardInput_.pop());
		}
	}

	public void initialize(TextField commandLine) {
		this.commandLine_ = commandLine;
		previousInput_ = new Stack<String>();
		forwardInput_ = new Stack<String>();
	}
	
	public void displayPreviousInput(){
		if(!previousInput_.isEmpty()){
			forwardInput_.push(previousInput_.peek());
			commandLine_.setText(previousInput_.pop());
			Platform.runLater(new Runnable() {
                @Override
                public void run() {
                    commandLine_.selectAll();
                }
			});
		}
	}
	
	public void displayForwardInput(){
		if(!forwardInput_.isEmpty()){
			previousInput_.push(forwardInput_.peek());
			commandLine_.setText(forwardInput_.pop());
			Platform.runLater(new Runnable() {
                @Override
                public void run() {
                    commandLine_.selectAll();
                }
			});
		}
	}
	
	public void pushInput(String input){
		previousInput_.push(input);
	}

}

	// End of segment: C:\Users\Jireh\Documents\CS2103T_main\src\gui\controller\CommandLineUtility.java





	/**
	 * origin: C:\Users\Jireh\Documents\CS2103T_main\src\gui\controller\HelperListener.java
	 */

 */
import gui.controller.view.HelperViewController;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;

public class HelperListener implements ChangeListener<String> {

	private HelperViewController helperViewController_;
	private AnimationHandler ah_;

	public HelperListener(HelperViewController helperViewController) {
		this.helperViewController_ = helperViewController;
		ah_ = AnimationHandler.getInstance();
	}

	@Override
	public void changed(ObservableValue<? extends String> observable,
			String oldValue, String newValue) {

		String firstWord = "";
		if ((newValue != null) && (newValue.replaceAll("\\s+", "")) != "") {
			String[] tokens = newValue.split("\\s+");
			if (tokens.length >= 1) {
				firstWord = newValue.split(" ")[0];
			}
		}

		if (firstWord.equalsIgnoreCase("add")
				|| firstWord.equalsIgnoreCase("add!")) {
			helperViewController_.setAddHelperView(newValue);
			ah_.displayHelper();
		} else if (newValue.length() < 2 && newValue.length() > 0) {
			helperViewController_.setAddHelperView("");
			ah_.revertView();
		}

		if(firstWord.equalsIgnoreCase("CLEAR")){
			setClearHelper(newValue);
		} else if (newValue.length() < 3 && newValue.length() > 0) {
			ah_.revertView();
		}
	}

	private void setClearHelper(String newValue) {		

		if (newValue.equalsIgnoreCase("CLEAR DONE")) {
			helperViewController_.setClearDoneHelperView();
			ah_.displayHelper();
		} else if (newValue.equalsIgnoreCase("CLEAR URGENT")) {
			helperViewController_.setClearUrgentHelperView();
			ah_.displayHelper();
		} else {
			helperViewController_.setClearAllHelperView();
			ah_.displayHelper();
		} 
	}
}

	// End of segment: C:\Users\Jireh\Documents\CS2103T_main\src\gui\controller\HelperListener.java





	/**
	 * origin: C:\Users\Jireh\Documents\CS2103T_main\src\gui\controller\PhantomClock.java
	 */

public class PhantomClock {
	

	private static PhantomClock pc_ = new PhantomClock();

	private PhantomClock(){
	}

	public static PhantomClock getInstance(){
		return pc_;
	}
	
	public void setClock(Label timeLabel){
		bindToTime(timeLabel);
	}

	private void bindToTime(Label timeLabel) {
		Timeline timeline = new Timeline(
				new KeyFrame(Duration.seconds(0),
						new EventHandler<ActionEvent>() {
					@Override public void handle(ActionEvent actionEvent) {
						Calendar time = Calendar.getInstance();
						String hourString = pad(2, ' ', time.get(Calendar.HOUR) == 0 ? "12" : time.get(Calendar.HOUR) + "");
						String minuteString = pad(2, '0', time.get(Calendar.MINUTE) + "");
						String secondString = pad(2, '0', time.get(Calendar.SECOND) + "");
						String ampmString = time.get(Calendar.AM_PM) == Calendar.AM ? "AM" : "PM";
						timeLabel.setText(hourString + ":" + minuteString + ":" + secondString + " " + ampmString);
					}
				}
						),
						new KeyFrame(Duration.seconds(1))
				);
		timeline.setCycleCount(Animation.INDEFINITE);
		timeline.play();
	}


	public static String pad(int fieldWidth, char padChar, String s) {
		StringBuilder sb = new StringBuilder();
		for (int i = s.length(); i < fieldWidth; i++) {
			sb.append(padChar);
		}
		sb.append(s);

		return sb.toString();
	}	

}

	// End of segment: C:\Users\Jireh\Documents\CS2103T_main\src\gui\controller\PhantomClock.java





	/**
	 * origin: C:\Users\Jireh\Documents\CS2103T_main\src\gui\controller\PreferenceManager.java
	 */

public class PreferenceManager {
	private static final String PREF_FILE_NAME = "Settings.txt";
	private static final String defaultCSS_ = "DarkTheme";
	private static final String[] DICTIONARY_THEMES = {"BlueTheme", "ChineseTheme","ChristmasTheme" ,"CogTheme", "DarkTheme",
		"DragonTheme", "GhostsTheme","GhostTheme" ,"GreenTheme", "HalloweenTheme",
		"RedTheme", "RoyalTheme","SingaporeTheme" ,"SnakeTheme", "WolfTheme"};

	private static PreferenceManager pm = new PreferenceManager();
	
	private File prefFile_;

	private String themeUrl_;

	private AnchorPane overallView_;

	private PreferenceManager(){
	}

	public static PreferenceManager getInstance(){		
		return pm;
	}

	public void initViews(AnchorPane overallView){
		this.overallView_ = overallView;
		initialize(PREF_FILE_NAME);
	}
	
	public void saveCSSPref(String cssFileName) throws IOException{	

		FileWriter fileWriter = new FileWriter(prefFile_, false);
		BufferedWriter buffer = new BufferedWriter(fileWriter);
		PrintWriter printWriter = new PrintWriter(buffer);

		String text = null;

		text = cssFileName;
		printWriter.println(cssFileName);

		printWriter.close();
		buffer.close();
		fileWriter.close();		
	}	
	
	public void setCss(String cssFileName){
		if(!dictionaryContains(DICTIONARY_THEMES,cssFileName)){
			cssFileName = defaultCSS_;
		}
		
		try{
			themeUrl_ = "main/Resources/css/" + cssFileName +".css";

			overallView_.getStylesheets().clear();
			overallView_.getStylesheets().add(themeUrl_);
			
		}catch(Exception e){
			System.out.println("error setting theme");
			MyLogger.log(Level.WARNING,"error setting theme");
		}
	}
	
	public String getThemeUrl(){
		return themeUrl_;
	}
	
	private void initialize(String prefFileName2) {
		prefFile_ = new File(PREF_FILE_NAME);
		try {
			if(!prefFile_.exists()){
				prefFile_.createNewFile();
			} else {
				setCssFromFile();
			}
		}catch (IOException e) {
			System.out.println("error");
		}

	}

	private void setCssFromFile() throws IOException {

		String cssFileName = defaultCSS_;

		BufferedReader br;
		try {
			br = new BufferedReader(new FileReader(PREF_FILE_NAME));
			cssFileName = br.readLine();
			br.close();
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}

		if(!dictionaryContains(DICTIONARY_THEMES,cssFileName)){
			cssFileName = defaultCSS_;
		}

		try{
			themeUrl_ = "main/Resources/css/" + cssFileName +".css";

			overallView_.getStylesheets().clear();
			overallView_.getStylesheets().add(themeUrl_);
		}catch(Exception e){
			System.out.println("theme uninitilised");
			MyLogger.log(Level.WARNING,"theme uninitilised");
		}
	}

	private boolean dictionaryContains(String[] dictionary, String keyword) {
		boolean isFound = false;
		for (int i = 0; i < dictionary.length; i++) {
			if (dictionary[i].equalsIgnoreCase(keyword)) {
				isFound = true;
				break;
			}
		}
		return isFound;
	}
}

	// End of segment: C:\Users\Jireh\Documents\CS2103T_main\src\gui\controller\PreferenceManager.java





	/**
	 * origin: C:\Users\Jireh\Documents\CS2103T_main\src\gui\controller\view\PhantomController.java
	 */

	final KeyCombination keyCombShiftRight = KeyCodeCombination.valueOf("Ctrl+RIGHT");
	final KeyCombination keyCombShiftLeft = KeyCodeCombination.valueOf("Ctrl+LEFT");

	// End of segment: C:\Users\Jireh\Documents\CS2103T_main\src\gui\controller\view\PhantomController.java





	/**
	 * origin: C:\Users\Jireh\Documents\CS2103T_main\src\gui\controller\view\PhantomController.java
	 */

	public void initPrefManager() {
		pm_ = PreferenceManager.getInstance();
		pm_.initViews(overallView_);
	}
	
	// End of segment: C:\Users\Jireh\Documents\CS2103T_main\src\gui\controller\view\PhantomController.java





	/**
	 * origin: C:\Users\Jireh\Documents\CS2103T_main\src\gui\controller\view\PhantomController.java
	 */

	public void animateRight(){
		ah_.animateRight();
	}

	public void animateLeft(){
		ah_.animateLeft();
	}
	
	// End of segment: C:\Users\Jireh\Documents\CS2103T_main\src\gui\controller\view\PhantomController.java





	/**
	 * origin: C:\Users\Jireh\Documents\CS2103T_main\src\gui\controller\view\PhantomController.java
	 */

//	private void play() {
//		final URL resource = getClass().getResource("a.mp3");
//		final Media media = new Media(resource.toString());
//		final MediaPlayer mediaPlayer = new MediaPlayer(media);
//		mediaPlayer.play();
//	}

	/*
	 * unused classes for initial testing with command buttons in gui
	 * 
	 * @FXML private void handleDeleteTask() { String numString =
	 * commandLine.getText(); commandLine.clear();
	 * 
	 * if(numString == null || numString.length() == 0){
	 * tfOutput.setText("Invalid deletion"); } else{ int lineNum =
	 * Integer.parseInt(numString); taskList.remove(lineNum - 1); for(int i =
	 * lineNum-1; i<taskList.size(); i++){ taskList.get(i).setPosition(i+1); } }
	 * }
	 * 
	 * @FXML private void handleAddTask() { String taskString =
	 * commandLine.getText(); commandLine.clear(); ModelTask task = new
	 * ModelTask(taskString, new Date(), taskList.size() + 1);
	 * taskList.add(task); }
	 * 
	 * @FXML private void handleClear(){ taskList.clear(); }
	 * 
	 * @FXML private void handleEditTask(){ switchToAll(); }
	 * 
	 * @FXML private void handleSearchTask(){
	 * tableViewController.setVisible(false); }
	 */
}

	// End of segment: C:\Users\Jireh\Documents\CS2103T_main\src\gui\controller\view\PhantomController.java





	/**
	 * origin: C:\Users\Jireh\Documents\CS2103T_main\src\gui\MainApp.java
	 */

		ta_ = TrayApplication.getInstance();
		try {
			ta_.createTrayIcon(primaryStage);
		} catch (IOException e) {
			e.printStackTrace();
		}
		sm_ = ShortcutManager.getInstance();
		Platform.setImplicitExit(false);
		sm_.setHotKeys(primaryStage);
		
	// End of segment: C:\Users\Jireh\Documents\CS2103T_main\src\gui\MainApp.java





	/**
	 * origin: C:\Users\Jireh\Documents\CS2103T_main\src\gui\MainApp.java
	 */

			/**
			 * This snippet of code allows 
			 * the user to remotely execute undo
			 * commands when CTRL+Z is pressed - smallson
			 */
			final KeyCombination keyCombUndo = new KeyCodeCombination(KeyCode.Z,
					KeyCombination.CONTROL_DOWN);
			scene.addEventHandler(KeyEvent.KEY_RELEASED, new EventHandler<KeyEvent>() {
				@Override
				public void handle(KeyEvent event) {
					if (keyCombUndo.match(event)) {
						controller.executeCommand("UNDO");

					}
				}
			});
			
			/**
			 * This snippet of code allows 
			 * the user to remotely execute redo
			 * commands when CTRL+R is pressed - smallson
			 */
			final KeyCombination keyCombRedo = new KeyCodeCombination(KeyCode.R,
					KeyCombination.CONTROL_DOWN);
			scene.addEventHandler(KeyEvent.KEY_RELEASED, new EventHandler<KeyEvent>() {
				@Override
				public void handle(KeyEvent event) {
					if (keyCombRedo.match(event)) {
						controller.executeCommand("REDO");
					}
				}
			});
			
			/**
			 * This snippet of code allows 
			 * the user to remotely execute clear
			 * commands when CTRL+L is pressed - smallson
			 */
			final KeyCombination keyCombClear = new KeyCodeCombination(KeyCode.L,
					KeyCombination.CONTROL_DOWN);
			scene.addEventHandler(KeyEvent.KEY_RELEASED, new EventHandler<KeyEvent>() {
				@Override
				public void handle(KeyEvent event) {
					if (keyCombClear.match(event)) {
						controller.executeCommand("CLEAR");
					}
				}
			});
			
			/**
	// End of segment: C:\Users\Jireh\Documents\CS2103T_main\src\gui\MainApp.java





	/**
	 * origin: C:\Users\Jireh\Documents\CS2103T_main\src\gui\ResourceLoader.java
	 */

/**
 * This class is used to load
 * external resources for use
 * in the GUI.
 * 
 * * Author: smallson
 */

final public class ResourceLoader {
	
	public static InputStream load(String path){
		InputStream input = ResourceLoader.class.getResourceAsStream(path);
		if(input == null){
			input = ResourceLoader.class.getResourceAsStream("/" + path);
		}
		return input;
	}
}

	// End of segment: C:\Users\Jireh\Documents\CS2103T_main\src\gui\ResourceLoader.java





	/**
	 * origin: C:\Users\Jireh\Documents\CS2103T_main\src\gui\ShortcutManager.java
	 */

public class ShortcutManager {

	private static ShortcutManager sm = new ShortcutManager();
	private static JIntellitype ji;
	private static TrayApplication ta;
//	private static PhantomController pc;

	private ShortcutManager(){
	}

	public static ShortcutManager getInstance(){
		return sm;
	}

	public void setHotKeys(Stage primaryStage){
		ji = JIntellitype.getInstance();
		ta = TrayApplication.getInstance();	
//		FXMLLoader loader = new FXMLLoader();
//		loader.setLocation(MainApp.class.getResource("view/OverallView.fxml"));
//		pc = loader.getController();
		ji.registerHotKey(1, JIntellitype.MOD_ALT, (int)'Q');
		ji.registerHotKey(2, JIntellitype.MOD_ALT, (int)'W');
		ji.registerHotKey(3, JIntellitype.MOD_ALT + JIntellitype.MOD_CONTROL, (int) 'Q');

		ji.addHotKeyListener(new HotkeyListener()
		{
			@Override
			public void onHotKey(int key) {
				if(key == 1){
					Platform.runLater(new Runnable(){
						public void run(){
							primaryStage.close();
							ta.showProgramIsMinimizedMsg();
						}
					});

				}
				if(key == 2){
					Platform.runLater(new Runnable(){
						public void run(){
							primaryStage.show();
						}
					});

				}
				if(key == 3){
					Platform.runLater(new Runnable(){
						public void run(){
							System.exit(0);
						}
					});
				}
			}
		});
	}
}

	// End of segment: C:\Users\Jireh\Documents\CS2103T_main\src\gui\ShortcutManager.java





	/**
	 * origin: C:\Users\Jireh\Documents\CS2103T_main\src\gui\TrayApplication.java
	 */

/**
 * This class is used to initialize
 * the tray application and to give
 * the gui tray functionalities
 * 
 * * Author: smallson
 */

public class TrayApplication {
	
	private static TrayApplication ta_ = new TrayApplication();
	private boolean firstTime_ = true;
    private TrayIcon trayIcon_;
    private java.awt.Image image_ = null;
	
	private TrayApplication(){
	}
	
	public static TrayApplication getInstance(){
		return ta_;
	}
	
	public void createTrayIcon(final Stage stage) throws IOException {
        if (SystemTray.isSupported()) {
            SystemTray tray = SystemTray.getSystemTray();
            image_ = ImageIO.read(ResourceLoader.load("ghost.png"));
          
            stage.setOnCloseRequest(new EventHandler<WindowEvent>() {
                @Override
                public void handle(WindowEvent t) {
                    hide(stage);
                }
            });
            // create a action listener to listen for default action executed on the tray icon
            final ActionListener closeListener = new ActionListener() {
                @Override
                public void actionPerformed(java.awt.event.ActionEvent e) {
                    System.exit(0);
                }
            };

            ActionListener showListener = new ActionListener() {
                @Override
                public void actionPerformed(java.awt.event.ActionEvent e) {
                    Platform.runLater(new Runnable() {
                        @Override
                        public void run() {
                            stage.show();
                        }
                    });
                }
            };
            // create a popup menu
            PopupMenu popup = new PopupMenu();

            MenuItem showItem = new MenuItem("Show");
            showItem.addActionListener(showListener);
            popup.add(showItem);

            MenuItem closeItem = new MenuItem("Close");
            closeItem.addActionListener(closeListener);
            popup.add(closeItem);
            // construct a TrayIcon
            trayIcon_ = new TrayIcon(image_, "Phantom", popup);
            // set the TrayIcon properties
            trayIcon_.addActionListener(showListener);
            // add the tray image
            try {
                tray.add(trayIcon_);
            } catch (AWTException e) {
                System.err.println(e);
            }
        }
    }

    public void showProgramIsMinimizedMsg() {
        if (firstTime_) {
            trayIcon_.displayMessage("Phantom",
                    " is running in the background",
                    TrayIcon.MessageType.INFO);
            firstTime_ = false;
        }
    }

    private void hide(final Stage stage) {
        Platform.runLater(new Runnable() {
            @Override
            public void run() {
                if (SystemTray.isSupported()) {
                	
                    stage.hide();
                    showProgramIsMinimizedMsg();
                } else {
                    System.exit(0);
                }
            }
        });
    }
}

	// End of segment: C:\Users\Jireh\Documents\CS2103T_main\src\gui\TrayApplication.java





	/**
	 * origin: C:\Users\Jireh\Documents\CS2103T_main\src\parser\CommandRetriever.java
	 */

public class CommandRetriever {
	
	/**
	 * String constants
	 */
	private final String STRING_SPACE = " ";
	
	/**
	 * Message constants
	 */
	private final String MESSAGE_INVALID_COMMAND = "Invalid command";
	
	/**
	 * Regex strings
	 */
	private final String ALPHANUM_REGEX = "^[a-zA-Z0-9|!]+$";

	private static CommandRetriever cr = new CommandRetriever();
	
	private CommandRetriever(){
	}

	public static CommandRetriever getInstance() {
		return cr;
	}

	protected String getCommandString(String input){
		if(input == null){
			return MESSAGE_INVALID_COMMAND;
		}
		input = input.trim();
		
		if(!input.split(STRING_SPACE)[0].matches(ALPHANUM_REGEX)){
			return MESSAGE_INVALID_COMMAND;
		}
		
		return input.split(STRING_SPACE)[0];
	}
}

	// End of segment: C:\Users\Jireh\Documents\CS2103T_main\src\parser\CommandRetriever.java





	/**
	 * origin: C:\Users\Jireh\Documents\CS2103T_main\src\parser\DateAndTimeChecker.java
	 */

public class DateAndTimeChecker {
	
	/**
	 * String constants
	 */
	private static final String STRING_SPACE = " ";
	private static final String STRING_DASH = "-";
	
	/**
	 * Integer constants
	 */
	private static final int INT_HOUR_TWELVE = 12;
	
	private static final int INT_MAX_HOUR= 23;
	private static final int INT_MAX_MINUTES = 59;
	private static final int INT_MAX_DAYS= 31;
	
	/**
	 * String dictionaries
	 */
	private static final String[] DICTIONARY_MONTHS = {"janurary","feburary","march","april","may","june","july","august","september","october","november","december",
		"jan","feb","mar","apr","jun","jul","aug","sept","sep","oct","nov","dec"};
	private static final String[] DICTIONARY_SUFFIX_TIME = {"AM","PM","MN","NN"};
	
	/**
	 * Regex constants
	 */	
	private static final String DEFAULT_TIME_REGEX = "(1[012]|[1-9])((:|.)[0-5][0-9])?(\\s)?(?i)(am|pm|mn|nn)";
	private static final String NUMBER_REGEX = "[^0-9]+";
	
	private static DateAndTimeChecker checker_ = new DateAndTimeChecker();
	
	private DateAndTimeChecker(){
	}
	
	protected static DateAndTimeChecker getInstance(){
		return checker_;
	}
	
	
	/**
	 * Time Verification
	 */
	public boolean isValidDefaultTimeFormat(String string) {
		
		if(!string.matches(DEFAULT_TIME_REGEX)){
			return false;
		}
		
		return verifyDefaultTimeFormat(string);
	}

	private boolean verifyDefaultTimeFormat(String string) {
		
		try{
			Scanner sc = new Scanner(string).useDelimiter(NUMBER_REGEX);		
			int integer = sc.nextInt();
			
			if(!dictionaryContains(DICTIONARY_SUFFIX_TIME,string.substring(string.length() - 2))){
				return false;
			}

			if(integer > INT_HOUR_TWELVE || integer <= 0){
				System.out.println("invalid time");
				return false;
			}
			
			if(sc.hasNextInt()){
				String minutes = string.substring(string.length() - 4, string.length() - 2);
				int temp = sc.nextInt();
				if(temp > INT_MAX_MINUTES || temp < 0 || temp != Integer.parseInt(minutes)){
					return false;
				}
			}
			
		} catch(Exception e){
			return false;
		}
		
		return true;
	}

	public boolean isValidMilitaryTimeFormat(String string) {
		
		string = string.replaceAll(":", "");

		return verifyMilitaryTimeFormat(string);
	}

	private boolean verifyMilitaryTimeFormat(String string) {
		try{
			String firstTwoDigits = string.substring(0,2);
			String lastTwoDigits = string.substring(2);
			
			if(Integer.parseInt(firstTwoDigits) < 0 || Integer.parseInt(lastTwoDigits) < 0){
				System.out.println("invalid military time format");
				return false;
			}

			if(Integer.parseInt(firstTwoDigits) > INT_MAX_HOUR || Integer.parseInt(lastTwoDigits) > INT_MAX_MINUTES){
				System.out.println("invalid military time format");
				return false;
			}

		}catch(Exception e){
			return false;
		}
		return true;
	}

	/**
	 * Date Verification
	 */

	public boolean isValidSlashDateFormat(String string){

		String [] num = string.split("/");

		return verifySlashDateFormat(num);
	}

	private boolean verifySlashDateFormat(String[] num) {
		if(num.length < 2 || num.length > 3)
			return false;
		
		try{
			if(Integer.parseInt(num[0]) > INT_MAX_DAYS || Integer.parseInt(num[0]) <= 0){
				System.out.println("invalid day");
				return false;
			}

		} catch (Exception e){
			//System.out.println("day exception");
			return false;
		}

		try{
			if(Integer.parseInt(num[1]) > INT_HOUR_TWELVE || Integer.parseInt(num[1]) <= 0){
				System.out.println("invalid month");
				return false;
			}

		} catch (Exception e){
			//System.out.println("month exception");
			return false;
		}

		if(num.length == 3){
			try{
				if(Integer.parseInt(num[2]) < 0){
					System.out.println("invalid year");
					return false;
				}

			} catch (Exception e){
				return false;
			}
		}
		return true;
	}

	public boolean isValidMonthFirstStringDateFormat(String[] words, int index) {

		try{
			String temp = words[index + 1];
			temp = temp.replaceAll("st","");
			temp = temp.replaceAll("nd","");
			temp = temp.replaceAll("rd","");
			temp = temp.replaceAll("th","");
			if(Integer.parseInt(temp) > INT_MAX_DAYS || Integer.parseInt(temp) <= 0){
				System.out.println("invalid string day");
				return false;
			}
		} catch(Exception e){
			return false;
		}
		return true;
	}

	public boolean isValidDayFirstStringDateFormat(String[] words, int index) {
		
		try{
			String temp = words[index - 1];
			temp = temp.replaceAll("st","");
			temp = temp.replaceAll("nd","");
			temp = temp.replaceAll("rd","");
			temp = temp.replaceAll("th","");
			if(Integer.parseInt(temp) > INT_MAX_DAYS || Integer.parseInt(temp) <= 0){
				System.out.println("invalid string day");
				return false;
			}
		} catch(Exception e){
	//		System.out.println("day first string day exception");
			return false;
		}

		return true;
	}

	public boolean isValidDashDateFormat(String toParse) {
		
		try{
			Scanner sc = new Scanner(toParse).useDelimiter(NUMBER_REGEX);		
			Integer firstInteger = sc.nextInt();
			Integer secondInteger = sc.nextInt();
			if(firstInteger >= secondInteger){
				return false;
			}
			if(firstInteger > INT_MAX_DAYS || secondInteger > INT_MAX_DAYS){
				return false;
			}
			String month = toParse.replace(firstInteger.toString(), "");
			month = month.replace(secondInteger.toString(), "");
			month = month.replace("-", "");
			if(!dictionaryContains(DICTIONARY_MONTHS,month)){
				return false;
			}
		} catch(Exception e){
			return false;
		}
		
		return true;
	}
	
	private boolean dictionaryContains(String[] dictionary, String keyword) {
		boolean isFound = false;
		for (int i = 0; i < dictionary.length; i++) {
			if (dictionary[i].equalsIgnoreCase(keyword)) {
				isFound = true;
				break;
			}
		}
		return isFound;
	}
	
	//depreciated
	public boolean isValidSingleStringDateFormat(String[] words, int index, int type) {
		
		String date = words[index].replaceAll("([^\\d-]?)(-?[\\d\\.]+)([^\\d]?)", "$1 $2 $3").replaceAll(" +", STRING_SPACE);
		String[] dateArray = date.split(STRING_SPACE);
		
		if(dateArray.length > 3 || dateArray.length < 2){
			System.out.println("valid");
			return false;
		}else if(Integer.parseInt(dateArray[type]) > INT_MAX_DAYS || Integer.parseInt(dateArray[type]) <= 0){
			return false;
		}
		return true;
	}
}

	// End of segment: C:\Users\Jireh\Documents\CS2103T_main\src\parser\DateAndTimeChecker.java





	/**
	 * origin: C:\Users\Jireh\Documents\CS2103T_main\src\parser\DateFormatter.java
	 */


public class DateFormatter {
	
	/**
	 * String constants
	 */
	private static final String STRING_SPACE = " ";
	private static final String STRING_SLASH = "/";
	
	/**
	 * String constants
	 */
	private static final int NUM_SINGLE_DAY_OFFSET = 1;
	
	/**
	 * String dictionaries
	 */
	private static final String[] DICTIONARY_TOMORROW = { "TOMORROW", "TMR" };
	
	/**
	 * Regex constants
	 */	
	private static final String NUMBER_REGEX = "[^0-9]+";
	
	/**
	 * Date formats
	 */
	private static final String SLASH_DATE_FORMAT = "dd/MM/YYYY";

	public DateFormatter(){			
	}

	public String convertDDformat(String date) {
		
		int offset = 0;

		if(dictionaryContains(DICTIONARY_TOMORROW,date)){
			offset = NUM_SINGLE_DAY_OFFSET;
			return getModifiedDate(offset);
		}
		
		DayParser dp = new DayParser();
		offset = dp.getDayIndex(date) - dp.getDayIndex(getCurrentDay());
		if(offset < 0){
			int temp = offset;
			if(temp == -6){
				offset = 1;
			} else if(temp == -5){
				offset = 2;
			} else if(temp == -4){
				offset = 3;
			} else if(temp == -3){
				offset = 4;
			} else if(temp == -2){
				offset = 5;
			} else if(temp == -1){
				offset = 6;
			}
		}
		return getModifiedDate(offset);
	}

	public String convertSDformat(String date) {
		String[] dateArray = date.split(STRING_SLASH);
		SimpleDateFormat dateFormat = new SimpleDateFormat(SLASH_DATE_FORMAT);
		Calendar calendar = Calendar.getInstance();
		
		calendar.set(Calendar.DAY_OF_MONTH, Integer.parseInt(dateArray[0]));
		calendar.set(Calendar.MONTH, Integer.parseInt(dateArray[1])- 1);
		if(yearExists(dateArray)){
			calendar.set(Calendar.YEAR, Integer.parseInt(dateArray[2]));
		}
		
		return dateFormat.format(calendar.getTime());
	}

	public String convertDFSformat(String date) {
		
		date = removeDaySuffix(date);
		MonthParser mp = new MonthParser();
		String[] dateArray = date.split(STRING_SPACE);
		SimpleDateFormat dateFormat = new SimpleDateFormat(SLASH_DATE_FORMAT);
		Calendar calendar = Calendar.getInstance();
		
		calendar.set(Calendar.DAY_OF_MONTH, Integer.parseInt(dateArray[0]));
		calendar.set(Calendar.MONTH, mp.getMonthIndex(dateArray[1]));
		if(yearExists(dateArray)){
			calendar.set(Calendar.YEAR, Integer.parseInt(dateArray[2]));
		}
		
		return dateFormat.format(calendar.getTime());
	}

	private boolean yearExists(String[] dateArray) {
		if (dateArray.length != 3){
			return false;
		}else if (!isValidYear(dateArray[2])){
			return false;
		}	
		return true;
	}

	private boolean isValidYear(String string) {
		Calendar now = Calendar.getInstance();
		Integer year = now.get(Calendar.YEAR);
		if(year > Integer.parseInt(string)){
			return false;
		} else if (string.length() > 4){
			return false;
		}
		return true;
	}

	public String convertMFSformat(String date) {
		
		date = removeDaySuffix(date);
		MonthParser mp = new MonthParser();
		String[] dateArray = date.split(STRING_SPACE);
		SimpleDateFormat dateFormat = new SimpleDateFormat(SLASH_DATE_FORMAT);
		Calendar calendar = Calendar.getInstance();
		
		calendar.set(Calendar.DAY_OF_MONTH, Integer.parseInt(dateArray[1]));
		calendar.set(Calendar.MONTH, mp.getMonthIndex(dateArray[0]));
		if(yearExists(dateArray)){
			calendar.set(Calendar.YEAR, Integer.parseInt(dateArray[2]));
		}
		
		return dateFormat.format(calendar.getTime());
	}

	private String removeDaySuffix(String date) {
		date = date.replaceAll("st","");
		date = date.replaceAll("nd","");
		date = date.replaceAll("rd","");
		date = date.replaceAll("th","");
		return date;
	}

	public String convertNDDformat(String date) {
		
		int offset = 0;
		
		DayParser dp = new DayParser();
		offset = dp.getDayIndex(date.split(STRING_SPACE)[1]) - dp.getDayIndex(getCurrentDay());
		if(offset < 0){
			int temp = offset;
			if(temp == -6){
				offset = 1;
			} else if(temp == -5){
				offset = 2;
			} else if(temp == -4){
				offset = 3;
			} else if(temp == -3){
				offset = 4;
			} else if(temp == -2){
				offset = 5;
			} else if(temp == -1){
				offset = 6;
			}
		}
		offset += 7;
		return getModifiedDate(offset);
	}
	
	private static String getCurrentDay(){
		String currDay;
		SimpleDateFormat dayFormat = new SimpleDateFormat("EEEE");

		Calendar calendar = Calendar.getInstance();
		currDay = dayFormat.format(calendar.getTime());
		
		return currDay;
	}
	
	private static String getModifiedDate(int offset){
		String currDate;
		SimpleDateFormat dayFormat = new SimpleDateFormat(SLASH_DATE_FORMAT);

		Calendar calendar = Calendar.getInstance();
		calendar.add(Calendar.DAY_OF_MONTH, offset);
		currDate = dayFormat.format(calendar.getTime());
		
		return currDate;
	}
	
	private boolean dictionaryContains(String[] dictionary, String keyword) {
		boolean isFound = false;
		for (int i = 0; i < dictionary.length; i++) {
			if (dictionary[i].equalsIgnoreCase(keyword)) {
				isFound = true;
				break;
			}
		}
		return isFound;
	}

	public String convertDDFformat(String date) {
		
		MonthParser mp = new MonthParser();
		Scanner sc = new Scanner(date).useDelimiter(NUMBER_REGEX);		
		Integer firstInteger = sc.nextInt();
		Integer secondInteger = sc.nextInt();
		String month = date.replace(firstInteger.toString(), "");
		month = month.replace(secondInteger.toString(), "");
		month = month.replace("-", "");
		
		SimpleDateFormat dateFormat = new SimpleDateFormat(SLASH_DATE_FORMAT);
		Calendar calendar = Calendar.getInstance();
		
		calendar.set(Calendar.DAY_OF_MONTH, firstInteger);
		calendar.set(Calendar.MONTH, mp.getMonthIndex(month));
		
		return dateFormat.format(calendar.getTime());
	}

	public String convertDDNformat(String date) {
		
		MonthParser mp = new MonthParser();
		Scanner sc = new Scanner(date).useDelimiter(NUMBER_REGEX);		
		Integer firstInteger = sc.nextInt();
		Integer secondInteger = sc.nextInt();
		String month = date.replace(firstInteger.toString(), "");
		month = month.replace(secondInteger.toString(), "");
		month = month.replace("-", "");
		
		SimpleDateFormat dateFormat = new SimpleDateFormat(SLASH_DATE_FORMAT);
		Calendar calendar = Calendar.getInstance();
		
		calendar.set(Calendar.DAY_OF_MONTH, secondInteger);
		calendar.set(Calendar.MONTH, mp.getMonthIndex(month));
		
		return dateFormat.format(calendar.getTime());
	}
}

	// End of segment: C:\Users\Jireh\Documents\CS2103T_main\src\parser\DateFormatter.java





	/**
	 * origin: C:\Users\Jireh\Documents\CS2103T_main\src\parser\DateParser.java
	 */


public class DateParser {

	/**
	 * String constants
	 */
	private static final String STRING_SPACE = " ";
	private static final String STRING_SLASH = "/";
	private static final String STRING_NEXT = "next";

	/**
	 * Tags
	 */
	private static final String FORMAT_DICTIONARY_DAY = "DD ";
	private static final String FORMAT_SLASH_DATE = "SD ";
	private static final String FORMAT_DAY_FIRST_STRING = "DFS ";
	private static final String FORMAT_MONTH_FIRST_STRING = "MFS ";
	private static final String FORMAT_NEXT_DICTIONARY_DAY = "NDD ";
	private static final String FORMAT_DASH_DATE_FIRST = "DDF ";
	private static final String FORMAT_DASH_DATE_NEXT = "DDN ";
	
	/**
	 * String Dictionaries
	 */
	private static final String[] DICTIONARY_DAYS = { "monday", "tuesday", "wednesday", "thursday", "friday","saturday", "sunday",
		"mon", "tue","tues","wed", "thurs","fri", "sat", "sun",	"tmr", "tomorrow"};

	private static final String[] DICTIONARY_MONTHS = {"janurary","feburary","march","april","may","june","july","august","september","october","november","december",
		"jan","feb","mar","apr","jun","jul","aug","sept","sep","oct","nov","dec"};

	//private static final String[] DICTIONARY_KEY_WORDS = {};


	private String date_ = null;
	private String dateStart_ = null;
	private String dateEnd_ = null;

	private DateAndTimeChecker checker = DateAndTimeChecker.getInstance();

	public DateParser(){

	}

	protected String getDate() {
		return date_;
	}

	protected String getDateStart() {
		return dateStart_;
	}

	protected String getDateEnd() {
		return dateEnd_;
	}

	protected void setDateStart(String date_){
		dateStart_ = date_;
	}

	protected String parseDateWithoutKeyword(String[] tokens, int i,String input){

		date_ = null;
		DateStandardizer ds = new DateStandardizer();

		input = checkInputsWithoutKeywords(tokens, i, input, ds);
		
		return input;
	}

	private String checkInputsWithoutKeywords(String[] tokens, int i,
			String input, DateStandardizer ds) {
		
		if(isNotOutOfBounds(i, tokens.length)){
			input = checkDictionaryDayWithoutKeyword(tokens, i, input, ds);
			input = checkSlashDateWithoutKeyword(tokens, i, input, ds);
		}

		input = checkMonthStringWithoutKeyword(tokens, i, input, ds);

		if(isNotOutOfBounds(i+1, tokens.length)){
			input = checkDayFirstStringWithoutKeyword(tokens, i, input, ds);
		}

		if(dictionaryEquals(DICTIONARY_MONTHS,tokens[i])){
			input = checkMonthFirstStringWithoutKeyword(tokens, i, input, ds);
		}

		if(tokens[i].equalsIgnoreCase(STRING_NEXT) && isNotOutOfBounds(i+1,tokens.length)){
			input = checkNextDictionaryDayWithoutKeyword(tokens, i, input, ds);
		}
		return input;
	}

	private String checkNextDictionaryDayWithoutKeyword(String[] tokens, int i,
			String input, DateStandardizer ds) {
		if(dictionaryEquals(DICTIONARY_DAYS,tokens[i+1])){
			if(!tokens[i+1].equalsIgnoreCase("tmr") && !tokens[i+1].equalsIgnoreCase("tommorrow")){
				date_ = "next " + tokens[i+1];
				input = input.replaceFirst(date_, "").trim();
				date_ = ds.formatDate(FORMAT_NEXT_DICTIONARY_DAY + date_);
				if(dateStart_ != null){
					adjustDayDate();
				}
			}
		}
		return input;
	}

	private String checkMonthFirstStringWithoutKeyword(String[] tokens, int i,
			String input, DateStandardizer ds) {
		if(checker.isValidMonthFirstStringDateFormat(tokens,i)){
			input = assignMonthFirstStringWithoutKeyword(tokens, i, input, ds);
		}
		return input;
	}

	private String assignMonthFirstStringWithoutKeyword(String[] tokens, int i,
			String input, DateStandardizer ds) {
		if(i+2 < tokens.length){
			try{
				if(Integer.parseInt(tokens[i+2]) > 0){
					date_ = tokens[i] + STRING_SPACE + tokens[i+1] + STRING_SPACE + tokens[i+2];
					input = input.replaceFirst(date_, "").trim();
					date_ = ds.formatDate(FORMAT_MONTH_FIRST_STRING + date_);
				}
				else{
					date_ = tokens[i] + STRING_SPACE + tokens[i+1];
					input = input.replaceFirst(date_, "").trim();
					date_ = ds.formatDate(FORMAT_MONTH_FIRST_STRING + date_);
				}
			} catch(Exception e){
				date_ = tokens[i] + STRING_SPACE + tokens[i+1];
				input = input.replaceFirst(date_, "").trim();
				date_ = ds.formatDate(FORMAT_MONTH_FIRST_STRING + date_);
			}
		}
		else {
			date_ = tokens[i] + STRING_SPACE + tokens[i+1];
			input = input.replaceFirst(date_, "").trim();
			date_ = ds.formatDate(FORMAT_MONTH_FIRST_STRING + date_);
		}

		if(dateStart_ != null){
			adjustDate();
		}
		return input;
	}

	private String checkDayFirstStringWithoutKeyword(String[] tokens, int i,
			String input, DateStandardizer ds) {
		if(dictionaryContains(DICTIONARY_MONTHS,tokens[i+1])){
			if(checker.isValidDayFirstStringDateFormat(tokens,i+1)){
				input = assignDayFirstStringWithoutKeyword(tokens, i, input, ds);
			}
		}
		return input;
	}

	private String assignDayFirstStringWithoutKeyword(String[] tokens, int i,
			String input, DateStandardizer ds) {
		
		if(i+2 < tokens.length){
			try{
				if(Integer.parseInt(tokens[i+2]) > 0){
					date_ = tokens[i] + STRING_SPACE + tokens[i+1] + STRING_SPACE + tokens[i+2];
					input = input.replaceFirst(date_, "").trim();
					date_ = ds.formatDate(FORMAT_DAY_FIRST_STRING + date_);
				}
				else{
					date_ = tokens[i] + STRING_SPACE + tokens[i+1];
					input = input.replaceFirst(date_, "").trim();
					date_ = ds.formatDate(FORMAT_DAY_FIRST_STRING + date_);
				}
			} catch(Exception e){
				date_ = tokens[i] + STRING_SPACE + tokens[i+1];
				input = input.replaceFirst(date_, "").trim();
				date_ = ds.formatDate(FORMAT_DAY_FIRST_STRING + date_);
			}
		}
		else{
			date_ = tokens[i] + STRING_SPACE + tokens[i+1];
			input = input.replaceFirst(date_, "").trim();
			date_ = ds.formatDate(FORMAT_DAY_FIRST_STRING + date_);
		}

		if(dateStart_ != null){
			adjustDate();
		}
		return input;
	}

	private String checkMonthStringWithoutKeyword(String[] tokens, int i,
			String input, DateStandardizer ds) {
		if(dictionaryContains(DICTIONARY_MONTHS,tokens[i])){
			
			String temp = tokens[i].replaceAll("(?<=[A-Za-z])(?=[0-9])|(?<=[0-9])(?=[A-Za-z])", " " ).trim();
			String[] dateArray = temp.split(STRING_SPACE);
			if(checker.isValidDayFirstStringDateFormat(dateArray, 1)){
				input = input.replaceFirst(tokens[i], "");
				date_ = ds.formatDate(FORMAT_DAY_FIRST_STRING + temp);
				if(dateStart_ != null){
					adjustDate();
				}
			}
			
			if(checker.isValidMonthFirstStringDateFormat(dateArray, 0)){
				input = input.replaceFirst(tokens[i], "");
				date_ = ds.formatDate(FORMAT_MONTH_FIRST_STRING + temp);
				if(dateStart_ != null){
					adjustDate();
				}
			}
		}
		return input;
	}

	private String checkSlashDateWithoutKeyword(String[] tokens, int i,
			String input, DateStandardizer ds) {
		if(tokens[i].contains("/")){
			if(checker.isValidSlashDateFormat(tokens[i])){
				date_ = tokens[i];
				input = input.replaceFirst(date_, "");
				date_ = ds.formatDate(FORMAT_SLASH_DATE + date_);
				if(dateStart_ != null){
					adjustDate();
				}
			}
		}
		return input;
	}

	private String checkDictionaryDayWithoutKeyword(String[] tokens, int i,
			String input, DateStandardizer ds) {
		if(dictionaryEquals(DICTIONARY_DAYS,tokens[i])){
			date_ = tokens[i];
			input = input.replaceFirst(date_, "").trim();
			date_ = ds.formatDate(FORMAT_DICTIONARY_DAY + date_);
			if(dateStart_ != null){
				adjustDayDate();
			}
		}
		return input;
	}

	protected String parseDashDateWithoutKeyword(String[] tokens, int i, String input) {

		DateStandardizer ds = new DateStandardizer();
		dateStart_ = null;
		dateEnd_ = null;
		String toParse = null;
		String toReplace = null;
		if(isNotOutOfBounds(i-1,tokens.length) && isNotOutOfBounds(i+2,tokens.length)){
			toParse = tokens[i-1] + tokens[i] + tokens[i+1] + tokens[i+2];
			toReplace = tokens[i-1] + STRING_SPACE + tokens[i] + STRING_SPACE + tokens[i+1] + STRING_SPACE + tokens[i+2];
		}
		else if (isNotOutOfBounds(i-1,tokens.length) && isNotOutOfBounds(i+1,tokens.length)){
			toParse = tokens[i-1] + tokens[i] + tokens[i+1];
			toReplace = tokens[i-1] + STRING_SPACE + tokens[i] + STRING_SPACE + tokens[i+1];
		} else {
			toParse = tokens[i];
			toReplace = tokens[i];
		}

		if(checker.isValidDashDateFormat(toParse.trim())){
			input = input.replaceFirst(toReplace, "");
			System.out.println(input);
			dateStart_ = ds.formatDate(FORMAT_DASH_DATE_FIRST + toParse.trim());
			dateEnd_ = ds.formatDate(FORMAT_DASH_DATE_NEXT + toParse.trim());
		}

		return input;
	}


	protected String parseDateWithKeyword(String[] tokens, int i, String input) {

		date_ = null;
		DateStandardizer ds = new DateStandardizer();
		String temp = "";

		input = checkInputsWithKeywords(tokens, i, input, ds);

		return input;
	}

	private String checkInputsWithKeywords(String[] tokens, int i,
			String input, DateStandardizer ds) {
		if(isNotOutOfBounds(i+1, tokens.length)){

			if(dictionaryEquals(DICTIONARY_DAYS,tokens[i+1])){
				input = checkDictionaryDayWithKeyword(tokens, i, input, ds);
			}

			if(tokens[i+1].contains("/")){
				input = checkSlashDateFormatWithKeyword(tokens, i, input, ds);
			}

			if(dictionaryContains(DICTIONARY_MONTHS,tokens[i+1])){				
				input = checkMonthStringWithKeyword(tokens, i, input, ds);
			}
		}

		if(isNotOutOfBounds(i+2, tokens.length)){
			
			input = checkDayFirstStringAndMonthFirstStringWithKeyword(tokens,
					i, input, ds);

			if(tokens[i+1].equalsIgnoreCase(STRING_NEXT)){
				input = checkNextDictionaryDayWithKeyword(tokens, i, input, ds);
			}
		}
		return input;
	}

	private String checkNextDictionaryDayWithKeyword(String[] tokens, int i,
			String input, DateStandardizer ds) {
		if(dictionaryEquals(DICTIONARY_DAYS,tokens[i+2])){
			if(!tokens[i+2].equalsIgnoreCase("tmr") && !tokens[i+2].equalsIgnoreCase("tommorrow")){
				date_ = "next " + tokens[i+2];
				input = input.replaceFirst(tokens[i] + STRING_SPACE + date_, "").trim();
				date_ = ds.formatDate(FORMAT_NEXT_DICTIONARY_DAY + date_);
				if(dateStart_ != null){
					adjustDayDate();
				}
			}
		}
		return input;
	}

	private String checkDayFirstStringAndMonthFirstStringWithKeyword(
			String[] tokens, int i, String input, DateStandardizer ds) {
		if(dictionaryEquals(DICTIONARY_MONTHS,tokens[i+2])){
			input = checkDayFirstStringWithKeyword(tokens, i, input, ds);
		}

		if(dictionaryEquals(DICTIONARY_MONTHS,tokens[i+1])){
			input = checkMonthFirstStringWithKeyword(tokens, i, input, ds);
		}
		return input;
	}

	private String checkMonthFirstStringWithKeyword(String[] tokens, int i,
			String input, DateStandardizer ds) {
		if(checker.isValidMonthFirstStringDateFormat(tokens,i+1)){
			input = assignMonthFirstStringWithKeyword(tokens, i, input, ds);
		}
		return input;
	}

	private String assignMonthFirstStringWithKeyword(String[] tokens, int i,
			String input, DateStandardizer ds) {
		if(i+3 < tokens.length){
			try{
				if(Integer.parseInt(tokens[i+3]) > 0){
					date_ = tokens[i+1] + STRING_SPACE + tokens[i+2] + STRING_SPACE + tokens[i+3];
					input = input.replaceFirst(tokens[i] + STRING_SPACE + date_, "").trim();
					date_ = ds.formatDate(FORMAT_MONTH_FIRST_STRING + date_);
				}
				else{
					date_ = tokens[i+1] + STRING_SPACE + tokens[i+2];
					input = input.replaceFirst(tokens[i] + STRING_SPACE + date_, "").trim();
					date_ = ds.formatDate(FORMAT_MONTH_FIRST_STRING + date_);
				}
			} catch(Exception e){
				date_ = tokens[i+1] + STRING_SPACE + tokens[i+2];
				input = input.replaceFirst(tokens[i] + STRING_SPACE + date_, "").trim();
				date_ = ds.formatDate(FORMAT_MONTH_FIRST_STRING + date_);
			}
		}
		else{
			date_ = tokens[i+1] + STRING_SPACE + tokens[i+2];
			input = input.replaceFirst(tokens[i] + STRING_SPACE + date_, "").trim();
			date_ = ds.formatDate(FORMAT_MONTH_FIRST_STRING + date_);
		}
		if(dateStart_ != null){
			adjustDate();
		}
		return input;
	}

	private String checkDayFirstStringWithKeyword(String[] tokens, int i,
			String input, DateStandardizer ds) {
		if(checker.isValidDayFirstStringDateFormat(tokens,i+2)){
			if(i+3 < tokens.length){
				try{
					if(Integer.parseInt(tokens[i+3]) > 0){
						date_ = tokens[i+1] + STRING_SPACE + tokens[i+2] + STRING_SPACE + tokens[i+3];
						input = input.replaceFirst(tokens[i] + STRING_SPACE + date_, "").trim();
						date_ = ds.formatDate(FORMAT_DAY_FIRST_STRING + date_);
					}
					else{
						date_ = tokens[i+1] + STRING_SPACE + tokens[i+2];
						input = input.replaceFirst(tokens[i] + STRING_SPACE + date_, "").trim();
						date_ = ds.formatDate(FORMAT_DAY_FIRST_STRING + date_);
					}
				} catch(Exception e){
					date_ = tokens[i+1] + STRING_SPACE + tokens[i+2];
					input = input.replaceFirst(tokens[i] + STRING_SPACE + date_, "").trim();
					date_ = ds.formatDate(FORMAT_DAY_FIRST_STRING + date_);
				}
			}
			else{
				date_ = tokens[i+1] + STRING_SPACE + tokens[i+2];
				input = input.replaceFirst(tokens[i] + STRING_SPACE + date_, "").trim();
				date_ = ds.formatDate(FORMAT_DAY_FIRST_STRING + date_);
			}

			if(dateStart_ != null){
				adjustDate();
			}
		}
		return input;
	}

	private String checkMonthStringWithKeyword(String[] tokens, int i,
			String input, DateStandardizer ds) {
		String temp;
		temp = tokens[i+1].replaceAll("(?<=[A-Za-z])(?=[0-9])|(?<=[0-9])(?=[A-Za-z])", " " ).trim();
		String[] dateArray = temp.split(STRING_SPACE);
		if(checker.isValidDayFirstStringDateFormat(dateArray, 1)){
			input = input.replaceFirst(tokens[i] + STRING_SPACE + tokens[i+1], "").trim();
			date_ = ds.formatDate(FORMAT_DAY_FIRST_STRING + temp);
			if(dateStart_ != null){
				adjustDate();
			}
		}
		if(checker.isValidMonthFirstStringDateFormat(dateArray, 0)){
			input = input.replaceFirst(tokens[i] + STRING_SPACE + tokens[i+1], "").trim();
			date_ = ds.formatDate(FORMAT_MONTH_FIRST_STRING + temp);
			if(dateStart_ != null){
				adjustDate();
			}
		}
		return input;
	}

	private String checkSlashDateFormatWithKeyword(String[] tokens, int i,
			String input, DateStandardizer ds) {
		if(checker.isValidSlashDateFormat(tokens[i+1])){
			date_ = tokens[i+1];
			input = input.replaceFirst(tokens[i] + STRING_SPACE + date_, "").trim();
			date_ = ds.formatDate(FORMAT_SLASH_DATE + date_);
			if(dateStart_ != null){
				adjustDate();
			}
		}
		return input;
	}

	private String checkDictionaryDayWithKeyword(String[] tokens, int i,
			String input, DateStandardizer ds) {
		date_ = tokens[i+1];
		input = input.replaceFirst(tokens[i] + STRING_SPACE + date_, "").trim();
		date_ = ds.formatDate(FORMAT_DICTIONARY_DAY + date_);
		if(dateStart_ != null){
			adjustDayDate();
		}
		return input;
	}

	private void adjustDate() {
		if(!validEndDate(date_,dateStart_)){
			date_ = getYearModifiedDate();
		}	
	}

	private void adjustDayDate() {
		if(!validEndDate(date_,dateStart_)){
			date_ = getWeekModifiedDate(7,date_);
		}
	}

	private boolean isNotOutOfBounds(int index, int length) {
		return index < length && index >= 0;
	}

	private boolean dictionaryEquals(String[] dictionary, String keyword) {
		boolean isFound = false;
		for (int i = 0; i < dictionary.length; i++) {
			if (dictionary[i].equalsIgnoreCase(keyword)) {
				isFound = true;
				break;
			}
		}
		return isFound;
	}

	private boolean dictionaryContains(String[] dictionary, String keyword) {
		boolean isFound = false;
		for (int i = 0; i < dictionary.length; i++) {
			if (keyword.contains(dictionary[i])) {
				isFound = true;
				break;
			}
		}
		return isFound;
	}

	private boolean validEndDate(String endDate, String startDate) {

		String[] endArray = endDate.split(STRING_SLASH);
		String[] startArray = startDate.split(STRING_SLASH);

		if(Integer.parseInt(endArray[2]) < Integer.parseInt(startArray[2])){
			return false;
		} if (Integer.parseInt(endArray[2]) == Integer.parseInt(startArray[2])){
			if (Integer.parseInt(endArray[1]) < Integer.parseInt(startArray[1])){
				return false;
			}
		} if (Integer.parseInt(endArray[1]) == Integer.parseInt(startArray[1])){
			if (Integer.parseInt(endArray[0]) < Integer.parseInt(startArray[0])){
				return false;
			}
		}

		return true;
	}

	private static String getWeekModifiedDate(int offset, String date_){

		String modDate;
		SimpleDateFormat dayFormat = new SimpleDateFormat("dd/MM/YYYY");

		String[] dateArray = date_.split(STRING_SLASH);
		int day = Integer.parseInt(dateArray[0]);
		int month = Integer.parseInt(dateArray[1]);
		int year = Integer.parseInt(dateArray[2]);

		Calendar calendar = Calendar.getInstance();
		calendar.set(year, month - 1, day);
		calendar.add(Calendar.DAY_OF_MONTH, offset);
		modDate = dayFormat.format(calendar.getTime());

		return modDate;
	}

	private String getYearModifiedDate() {		

		String modDate;
		SimpleDateFormat dayFormat = new SimpleDateFormat("dd/MM/YYYY");

		String[] dateArray = date_.split(STRING_SLASH);
		int day = Integer.parseInt(dateArray[0]);
		int month = Integer.parseInt(dateArray[1]);
		int year = Integer.parseInt(dateArray[2]);

		Calendar calendar = Calendar.getInstance();
		calendar.set(year, month - 1, day);
		calendar.add(Calendar.YEAR, 1);
		modDate = dayFormat.format(calendar.getTime());

		return modDate;
	}	

}

	// End of segment: C:\Users\Jireh\Documents\CS2103T_main\src\parser\DateParser.java





	/**
	 * origin: C:\Users\Jireh\Documents\CS2103T_main\src\parser\DateStandardizer.java
	 */


public class DateStandardizer {
	
	/**
	 * String constants
	 */
	private final String STRING_SPACE = " ";
	
	/**
	 * Format types
	 */
	private static enum FormatType {
		DD, SD, DFS, MFS, NDD, DDF, DDN, INVALID
		};
		
	private static final String FORMAT_DICTIONARY_DAY = "DD";
	private static final String FORMAT_SLASH_DATE = "SD";
	private static final String FORMAT_DAY_FIRST_STRING = "DFS";
	private static final String FORMAT_MONTH_FIRST_STRING = "MFS";
	private static final String FORMAT_NEXT_DICTIONARY_DAY = "NDD";	
	private static final String FORMAT_DASH_DATE_FIRST = "DDF";	
	private static final String FORMAT_DASH_DATE_NEXT = "DDN";	
	
	public DateStandardizer(){
	}
	
	public String formatDate(String date){
		
		String dateFormat = date.split(STRING_SPACE).clone()[0];
		date = date.replaceFirst(dateFormat, "").trim();
		FormatType formatType = getFormatType(dateFormat);
		DateFormatter df = new DateFormatter();
		
		switch (formatType) {
		case DD :
	//		System.out.println("Date Format: DD");
			date = df.convertDDformat(date);
			break;
		case SD :
	//		System.out.println("Date Format: SD");
			date = df.convertSDformat(date);
			break;
		case DFS :
	//		System.out.println("Date Format: DFS");
			date = df.convertDFSformat(date);
			break;
		case MFS :
	//		System.out.println("Date Format: MFS");
			date = df.convertMFSformat(date);
			break;
		case NDD:
	//		System.out.println("Date Format: NDD");
			date = df.convertNDDformat(date);
			break;
		case DDF:
	//		System.out.println("Date Format: DDF");
			date = df.convertDDFformat(date);
			break;
		case DDN:
	//		System.out.println("Date Format: DDN");
			date = df.convertDDNformat(date);
			break;
		case INVALID :
			break;
		default :
			MyLogger.log(Level.SEVERE, "Fatal error has occured in DateStandardizer!");
			assert true;
		}	
		
		return date;
	}
	
	private static FormatType getFormatType(String format) {
		
		if (format.equalsIgnoreCase(FORMAT_DICTIONARY_DAY)) {
			return FormatType.DD;
		} else if (format.equalsIgnoreCase(FORMAT_SLASH_DATE)) {
			return FormatType.SD;
		} else if (format.equalsIgnoreCase(FORMAT_DAY_FIRST_STRING)) {
			return FormatType.DFS;
		} else if (format.equalsIgnoreCase(FORMAT_MONTH_FIRST_STRING)) {
			return FormatType.MFS;
		} else if (format.equalsIgnoreCase(FORMAT_NEXT_DICTIONARY_DAY)) {
			return FormatType.NDD;
		}else if (format.equalsIgnoreCase(FORMAT_DASH_DATE_FIRST)) {
			return FormatType.DDF;
		}else if (format.equalsIgnoreCase(FORMAT_DASH_DATE_NEXT)) {
			return FormatType.DDN;
		}else {
			return FormatType.INVALID;
		}
	}
}

	// End of segment: C:\Users\Jireh\Documents\CS2103T_main\src\parser\DateStandardizer.java





	/**
	 * origin: C:\Users\Jireh\Documents\CS2103T_main\src\parser\DayParser.java
	 */


public class DayParser {
	
	/**
	 * Dictionary of days
	 */
	private static final String[] DICTIONARY_SUNDAY = { "SUNDAY", "SUN" };
	private static final String[] DICTIONARY_MONDAY = { "MONDAY", "MON" };
	private static final String[] DICTIONARY_TUESDAY = { "TUESDAY", "TUE", "TUES" };
	private static final String[] DICTIONARY_WEDNESDAY = { "WEDNESDAY", "WED" };
	private static final String[] DICTIONARY_THURSDAY = { "THURSDAY", "THUR", "THURS" };
	private static final String[] DICTIONARY_FRIDAY = { "FRIDAY", "FRI" };
	private static final String[] DICTIONARY_SATURDAY = { "SATURDAY", "SAT" };
	
	/**
	 * Numerical representation
	 */
	private static final int NUM_MONDAY = 1;
	private static final int NUM_TUESDAY = 2;
	private static final int NUM_WEDNESDAY = 3;
	private static final int NUM_THURSDAY = 4;
	private static final int NUM_FRIDAY = 5;
	private static final int NUM_SATURDAY = 6;
	private static final int NUM_SUNDAY = 7;
	private static final int NUM_DEFAULT = 0;

	public int getDayIndex(String date) {
		
		if(dictionaryContains(DICTIONARY_SUNDAY,date)){
			return NUM_SUNDAY;
		}else if(dictionaryContains(DICTIONARY_MONDAY,date)){
			return NUM_MONDAY;
		}else if(dictionaryContains(DICTIONARY_TUESDAY,date)){
			return NUM_TUESDAY;
		}else if(dictionaryContains(DICTIONARY_WEDNESDAY,date)){
			return NUM_WEDNESDAY;
		}else if(dictionaryContains(DICTIONARY_THURSDAY,date)){
			return NUM_THURSDAY;
		}else if(dictionaryContains(DICTIONARY_FRIDAY,date)){
			return NUM_FRIDAY;
		}else if(dictionaryContains(DICTIONARY_SATURDAY,date)){
			return NUM_SATURDAY;
		} 
			return NUM_DEFAULT;
	}
	
	private boolean dictionaryContains(String[] dictionary, String keyword) {
		boolean isFound = false;
		for (int i = 0; i < dictionary.length; i++) {
			if (dictionary[i].equalsIgnoreCase(keyword)) {
				isFound = true;
				break;
			}
		}
		return isFound;
	}

}

	// End of segment: C:\Users\Jireh\Documents\CS2103T_main\src\parser\DayParser.java





	/**
	 * origin: C:\Users\Jireh\Documents\CS2103T_main\src\parser\InputParser.java
	 */


public class InputParser {

	/**
	 * String constants
	 */
	private static final String STRING_SPACE = " ";
	private static final String STRING_DASH = "-";
	private static final String STRING_SLASH = "/";
	private static final String STRING_WAVE_DASH = "~";
	private static final String STRING_TO = "TO";
	private static final String STRING_BEFORE_MIDNIGHT = "2359";

	/**
	 * String Dictionaries
	 */
	private final String[] DICTIONARY_KEYWORDS_DEADLINE = { "BY", "BEFORE"};
	private final String[] DICTIONARY_KEYWORDS_STARTTIME = { "AT", "FROM", "ON"};
	private final String[] DICTIONARY_KEYWORDS_ENDTIME = { "TO" , "-" , "UNTIL", "TIL"};
	private final String[] DICTIONARY_KEYWORDS_TODAY = { "TODAY", "TDY" };
	//	private final String[] DICTIONARY_KEYWORDS_DASH = { "-", "~" };

	/**
	 * Required information from input
	 */
	private String taskDescription_;
	private String startTime_;
	private String endTime_;
	private String deadLine_;
	private String endDate_;
	private String startDate_;

	private boolean isDeadLineFound_;
	private boolean isStartTimeFound_;
	private boolean isStartDateFound_;
	private boolean isEndTimeFound_;
	private boolean isEndDateFound_;

	public InputParser(){
		taskDescription_ = null;
		startDate_ = null;
		startTime_ = null;
		endDate_ = null;
		endTime_ = null;
		deadLine_ = null;

		isDeadLineFound_ = false;
		isStartTimeFound_ = false;
		isStartDateFound_ = false;
		isEndTimeFound_ = false;
		isEndDateFound_ = false;
	}

	public String getTaskDescription(){
		return taskDescription_.replaceAll("\\s+", " ");
	}
	public String getStartDate(){
		return startDate_;
	}
	public String getStartTime(){
		return startTime_;
	}
	public String getEndDate(){
		return endDate_;
	}
	public String getEndTime(){
		return endTime_;
	}
	public String getDeadLine(){
		return deadLine_;
	}

	public void parseInput(String input){

		input = replaceCommandWord(input);

		DateParser dp = new DateParser();
		TimeParser tp = new TimeParser();
		ParseFreeManager pfm = ParseFreeManager.getInstance();

		input = pfm.getParseFreeInput(input);
		String[] tokens = input.split(STRING_SPACE);

		for (int i = 0; i < tokens.length; i++) {
			input = parseWord(input, dp, tp, tokens, i);
		}

		postParsingAdjustments();

		input = pfm.replaceParseFree(input);
		taskDescription_ = input;						
	}

	private String parseWord(String input, DateParser dp, TimeParser tp,
			String[] tokens, int i) {
		
		input = parseWithoutKeyword(input, dp, tp, tokens, i);
		input = parseDeadline(input, dp, tp, tokens, i);
		input = parseTimed(input, dp, tp, tokens, i);
		
		return input;
	}

	private String parseTimed(String input, DateParser dp, TimeParser tp,
			String[] tokens, int i) {
		
		input = parseStart(input, dp, tp, tokens, i);
		input = parseEnd(input, dp, tp, tokens, i);

		return input;
	}

	private String parseEnd(String input, DateParser dp, TimeParser tp,
			String[] tokens, int i) {
		
		if(dictionaryContains(DICTIONARY_KEYWORDS_ENDTIME, tokens[i])){
			
			input = parseEndDate(input, dp, tokens, i);
			input = parseEndTime(input, tp, tokens, i);

		}
		return input;
	}

	private String parseEndTime(String input, TimeParser tp, String[] tokens,
			int i) {
		if(!isEndTimeFound_){
			input = tp.parseTimeWithKeyword(tokens, i, input);
			if(tp.getTime() != null){
				endTime_ = tp.getTime();
				isEndTimeFound_ = true;
			}
		}
		return input;
	}

	private String parseEndDate(String input, DateParser dp, String[] tokens,
			int i) {
		if(!isEndDateFound_){
			input = dp.parseDateWithKeyword(tokens, i, input);
			if(dp.getDate() != null){
				endDate_ = dp.getDate();
				isEndDateFound_ = true;
			}
		}
		return input;
	}

	private String parseStart(String input, DateParser dp, TimeParser tp,
			String[] tokens, int i) {
		
		if(dictionaryContains(DICTIONARY_KEYWORDS_STARTTIME, tokens[i])){

			input = parseDashDate(input, tp, tokens, i);
			input = parseStartDate(input, dp, tokens, i);		
			input = parseToday(input, tokens, i);
			input = parseStartTime(input, tp, tokens, i);

		}
		return input;
	}

	private String parseStartTime(String input, TimeParser tp, String[] tokens,
			int i) {
		if(!isStartTimeFound_){
			input = tp.parseTimeWithKeyword(tokens, i, input);
			if(tp.getTime() != null){
				startTime_ = tp.getTime();
				isStartTimeFound_ = true;
			}
		}
		return input;
	}

	private String parseToday(String input, String[] tokens, int i) {
		if(isNotOutOfBounds(i+1,tokens.length) && !isStartDateFound_){
			if(dictionaryContains(DICTIONARY_KEYWORDS_TODAY, tokens[i+1])){
				startDate_ = getCurrentDate();
				isStartDateFound_ = true;
				input = input.replaceFirst(tokens[i] + STRING_SPACE + tokens[i+1], "").trim();
			}
		}
		return input;
	}

	private String parseStartDate(String input, DateParser dp, String[] tokens,
			int i) {
		if(!isStartDateFound_){
			input = dp.parseDateWithKeyword(tokens, i, input);
			if(dp.getDate() != null){
				startDate_ = dp.getDate();
				dp.setDateStart(startDate_);
				isStartDateFound_ = true;
			}
		}
		return input;
	}

	private String parseDashDate(String input, TimeParser tp, String[] tokens,
			int i) {
		if(!isStartTimeFound_ && !isEndTimeFound_){
			input = tp.parseDashTimeWithKeyword(tokens, i, input);
			if(tp.getStart() != null && tp.getEnd() != null){
				startTime_ = tp.getStart();
				endTime_ = tp.getEnd();
				isStartTimeFound_ = true;
				isEndTimeFound_ = true;
			}
		}
		return input;
	}

	private String parseDeadline(String input, DateParser dp, TimeParser tp,
			String[] tokens, int i) {
		if(dictionaryContains(DICTIONARY_KEYWORDS_DEADLINE, tokens[i])){
			if(!isDeadLineFound_){
				input = dp.parseDateWithKeyword(tokens, i, input);
				if(dp.getDate() != null){
					deadLine_ = dp.getDate();
					isDeadLineFound_ = true;
				}
			}

			input = parseEndTime(input, tp, tokens, i);	

			if(isNotOutOfBounds(i+1,tokens.length) && !isEndTimeFound_){
				if(dictionaryContains(DICTIONARY_KEYWORDS_TODAY, tokens[i+1])){
					endTime_ = STRING_BEFORE_MIDNIGHT;
					isEndTimeFound_ = true;
					input = input.replaceFirst(tokens[i] + STRING_SPACE + tokens[i+1], "").trim();
				}
			}
		}
		return input;
	}

	private String parseWithoutKeyword(String input, DateParser dp,
			TimeParser tp, String[] tokens, int i) {
		
		if(!isDeadLineFound_ && !isEndDateFound_ && !isStartDateFound_ && previousNotKeyWord(tokens,i,input)){
			input = dp.parseDateWithoutKeyword(tokens, i, input);
			if(dp.getDate() != null){
				startDate_ = dp.getDate();
				dp.setDateStart(startDate_);
				isStartDateFound_ = true;
			}
		}

		if(!isStartTimeFound_ && !isEndTimeFound_){
			input = tp.parseDashTimeWithoutKeyword(tokens, i, input);
			if(tp.getStart() != null && tp.getEnd() != null){
				startTime_ = tp.getStart();
				endTime_ = tp.getEnd();
				isStartTimeFound_ = true;
				isEndTimeFound_ = true;
			}
		}

		if((!isStartTimeFound_ || !isEndTimeFound_) && previousNotKeyWord(tokens,i,input)){
			input = tp.parseTimeWithoutKeyword(tokens, i, input);
			if(tp.getTime() != null){
				if(!isStartTimeFound_){
					startTime_ = tp.getTime();
					isStartTimeFound_ = true;
				} else if(!isEndTimeFound_) {
					endTime_ = tp.getTime();
					isEndTimeFound_ = true;
				}
			}
			
			if(dictionaryContains(DICTIONARY_KEYWORDS_TODAY, tokens[i]) && !isEndTimeFound_){
				endTime_ = STRING_BEFORE_MIDNIGHT;
				isEndTimeFound_ = true;
				input = input.replaceFirst(tokens[i], "").trim();
			}
		}

		if(!isStartDateFound_ && !isEndDateFound_){
			if(tokens[i].contains(STRING_DASH) || (tokens[i].contains(STRING_WAVE_DASH)) || (tokens[i].contains(STRING_TO))){
				input = dp.parseDashDateWithoutKeyword(tokens, i, input);
				if(dp.getDateStart() != null && dp.getDateEnd() != null){
					startDate_ = dp.getDateStart();
					endDate_ = dp.getDateEnd();
					isStartDateFound_ = true;
					isEndDateFound_ = true;
				}
			}
		}
		return input;
	}

	private void postParsingAdjustments() {
		
		convertDeadLineToStartDate();
		convertDateAndTime();
	}

	private void convertDateAndTime() {
		
		assignDateIfTimeFound();	
		adjustEndDateAccordingToStartDateAndTime();
		assignTimeIfOnlyDeadLineFound();
		removeDeadLineIfTimedTask();
	}

	private void removeDeadLineIfTimedTask() {
		if(allDatesFound()){
			deadLine_ = null;
		}
	}

	private void assignTimeIfOnlyDeadLineFound() {
		if(onlyDeadLineFound()){
			endTime_ = STRING_BEFORE_MIDNIGHT;
		}
	}

	private void adjustEndDateAccordingToStartDateAndTime() {
		if(isStartDateFound_ && isStartTimeFound_ && isEndTimeFound_ && !isEndDateFound_){
			if(Integer.parseInt(endTime_) < Integer.parseInt(startTime_)){
				endDate_ = getDayModifiedDate(1,startDate_);
				isEndDateFound_ = true;
			}
		}
	}

	private void assignDateIfTimeFound() {
		if(!isDeadLineFound_ && !isStartDateFound_ && !isEndDateFound_){

			String temp = null;

			if(isEndTimeFound_){
				temp = endTime_;
			}
			if(isStartTimeFound_){
				temp = startTime_;
			}

			if(isStartTimeFound_ && isEndTimeFound_){
				if(Integer.parseInt(endTime_) < Integer.parseInt(startTime_)){
					startDate_ = getModifiedDate(0);
					endDate_ = getModifiedDate(1);
					isStartDateFound_ = true;
					isEndDateFound_ = true;
				} 
			} 
			if (temp != null){
				try{
					if(Integer.parseInt(getCurrentTime()) > Integer.parseInt(temp)){
						deadLine_ = getModifiedDate(1);
						isDeadLineFound_ = true;
					}
					else{
						deadLine_ = getModifiedDate(0);
						isDeadLineFound_ = true;
					}
				}catch(Exception e){
					System.out.println("error");
				}
			}
		}
	}

	private void convertDeadLineToStartDate() {
		if(isEndDateFound_ && isDeadLineFound_ && !isStartDateFound_){
			if(validEndDate(endDate_ , deadLine_)){
				startDate_ = deadLine_;
				deadLine_ = null;
				isStartDateFound_ = true;
			} 
		}
	}

	private String getCurrentDate() {
		String currDate;
		SimpleDateFormat dayFormat = new SimpleDateFormat("dd/MM/YYYY");

		Calendar calendar = Calendar.getInstance();
		currDate = dayFormat.format(calendar.getTime());

		return currDate;
	}

	private boolean previousNotKeyWord(String[] tokens, int i, String input) {
		
		try{
			if(dictionaryContains(DICTIONARY_KEYWORDS_DEADLINE,tokens[i-1])){
				return false;
			} else if (dictionaryContains(DICTIONARY_KEYWORDS_STARTTIME,tokens[i-1])){
				return false;
			} else if (dictionaryContains(DICTIONARY_KEYWORDS_ENDTIME,tokens[i-1])){
				return false;
			}
		} catch (IndexOutOfBoundsException e){
			return false;
		}
		return true;
	}
	
	private static String getDayModifiedDate(int offset, String date){

		String modDate;
		SimpleDateFormat dayFormat = new SimpleDateFormat("dd/MM/YYYY");

		String[] dateArray = date.split(STRING_SLASH);
		int day = Integer.parseInt(dateArray[0]);
		int month = Integer.parseInt(dateArray[1]);
		int year = Integer.parseInt(dateArray[2]);

		Calendar calendar = Calendar.getInstance();
		calendar.set(year, month - 1, day);
		calendar.add(Calendar.DAY_OF_MONTH, offset);
		modDate = dayFormat.format(calendar.getTime());

		return modDate;
	}

	private boolean allDatesFound() {
		return isDeadLineFound_ && isStartDateFound_ && isEndDateFound_;
	}

	private boolean onlyDeadLineFound() {
		return isDeadLineFound_ && !isStartDateFound_ && !isEndDateFound_ && !isStartTimeFound_ && !isEndTimeFound_;
	}

	private boolean isNotOutOfBounds(int index, int length) {
		return index < length && index > 0;
	}

	private boolean validEndDate(String endDate_, String startDate_) {

		String[] endArray = endDate_.split(STRING_SLASH);
		String[] startArray = startDate_.split(STRING_SLASH);

		if(Integer.parseInt(endArray[2]) < Integer.parseInt(startArray[2])){
			return false;
		} if (Integer.parseInt(endArray[2]) == Integer.parseInt(startArray[2])){
			if (Integer.parseInt(endArray[1]) < Integer.parseInt(startArray[1])){
				return false;
			}
		} if (Integer.parseInt(endArray[1]) == Integer.parseInt(startArray[1])){
			if (Integer.parseInt(endArray[0]) < Integer.parseInt(startArray[0])){
				return false;
			}
		}

		return true;
	}

	private String replaceCommandWord(String input) {
		return input.replaceFirst(input.split(STRING_SPACE)[0], "").trim();
	}

	private boolean dictionaryContains(String[] dictionary, String keyword) {
		boolean isFound = false;
		for (int i = 0; i < dictionary.length; i++) {
			if (dictionary[i].equalsIgnoreCase(keyword)) {
				isFound = true;
				break;
			}
		}
		return isFound;
	}

	private String getCurrentTime(){
		SimpleDateFormat currTime = new SimpleDateFormat("HHmm");//dd/MM/yyyy
		Date now = new Date();
		String strTime = currTime.format(now);
		return strTime;
	}

	private static String getModifiedDate(int offset){
		String modDate;
		SimpleDateFormat dayFormat = new SimpleDateFormat("dd/MM/YYYY");

		Calendar calendar = Calendar.getInstance();
		calendar.add(Calendar.DAY_OF_MONTH, offset);
		modDate = dayFormat.format(calendar.getTime());

		return modDate;
	}	
}

	// End of segment: C:\Users\Jireh\Documents\CS2103T_main\src\parser\InputParser.java





	/**
	 * origin: C:\Users\Jireh\Documents\CS2103T_main\src\parser\MonthParser.java
	 */


public class MonthParser {
	
	/**
	 * Dictionary of months
	 */
	private static final String[] DICTIONARY_JANURARY = { "JANURARY", "JAN" };
	private static final String[] DICTIONARY_FEBURARY = { "FEBURARY", "FEB" };
	private static final String[] DICTIONARY_MARCH = { "MARCH", "MAR" };
	private static final String[] DICTIONARY_APRIL = { "APRIL", "APR" };
	private static final String[] DICTIONARY_MAY = { "MAY" };
	private static final String[] DICTIONARY_JUNE = { "JUNE", "JUN" };
	private static final String[] DICTIONARY_JULY = { "JULY", "JUL" };
	private static final String[] DICTIONARY_AUGUST = { "AUGUST", "AUG" };
	private static final String[] DICTIONARY_SEPTEMBER = { "SEPTEMBER", "SEP", "SEPT" };
	private static final String[] DICTIONARY_OCTOBER = { "OCTOBER", "OCT" };
	private static final String[] DICTIONARY_NOVEMBER = { "NOVEMBER", "NOV" };
	private static final String[] DICTIONARY_DECEMBER = { "DECEMBER", "DEC" };
	
	/**
	 * Numerical representation
	 */
	private static final int NUM_JAN = 0;
	private static final int NUM_FEB = 1;
	private static final int NUM_MAR = 2;
	private static final int NUM_APR = 3;
	private static final int NUM_MAY = 4;
	private static final int NUM_JUN = 5;
	private static final int NUM_JUL = 6;
	private static final int NUM_AUG = 7;
	private static final int NUM_SEP = 8;
	private static final int NUM_OCT = 9;
	private static final int NUM_NOV = 10;
	private static final int NUM_DEC = 11;
	private static final int NUM_DEFAULT = -1;

	public int getMonthIndex(String string) {
		
		if(dictionaryContains(DICTIONARY_JANURARY,string)){
			return NUM_JAN;
		}else if(dictionaryContains(DICTIONARY_FEBURARY,string)){
			return NUM_FEB;
		}else if(dictionaryContains(DICTIONARY_MARCH,string)){
			return NUM_MAR;
		}else if(dictionaryContains(DICTIONARY_APRIL,string)){
			return NUM_APR;
		}else if(dictionaryContains(DICTIONARY_MAY,string)){
			return NUM_MAY;
		}else if(dictionaryContains(DICTIONARY_JUNE,string)){
			return NUM_JUN;
		}else if(dictionaryContains(DICTIONARY_JULY,string)){
			return NUM_JUL;
		}else if(dictionaryContains(DICTIONARY_AUGUST,string)){
			return NUM_AUG;
		}else if(dictionaryContains(DICTIONARY_SEPTEMBER,string)){
			return NUM_SEP;
		}else if(dictionaryContains(DICTIONARY_OCTOBER,string)){
			return NUM_OCT;
		}else if(dictionaryContains(DICTIONARY_NOVEMBER,string)){
			return NUM_NOV;
		}else if(dictionaryContains(DICTIONARY_DECEMBER,string)){
			return NUM_DEC;
		}
		
		return NUM_DEFAULT;
	}
	
	private boolean dictionaryContains(String[] dictionary, String keyword) {
		boolean isFound = false;
		for (int i = 0; i < dictionary.length; i++) {
			if (dictionary[i].equalsIgnoreCase(keyword)) {
				isFound = true;
				break;
			}
		}
		return isFound;
	}

}

	// End of segment: C:\Users\Jireh\Documents\CS2103T_main\src\parser\MonthParser.java





	/**
	 * origin: C:\Users\Jireh\Documents\CS2103T_main\src\parser\ParseFreeManager.java
	 */


public class ParseFreeManager {
	

	private static ParseFreeManager pfm = new ParseFreeManager();
	
	private static final String STRING_QUOTE = "\"";
	
	private static final int NOT_FOUND = -1;
	private static final int INT_ZERO = 0;
	private static final int INT_OFFSET = 1;
	
	private String parseFreeString_;
	private String parseFreeInput_ = "";

	private ParseFreeManager(){
	}

	public static ParseFreeManager getInstance(){
		return pfm;
	}
	
	public String getParseFreeInput(String input){
		
		parseFreeString_ = "";
		parseFreeInput_ = input;
		
		int startIndex = NOT_FOUND;
		int endIndex = NOT_FOUND;
		
		if(input.contains(STRING_QUOTE)){
			startIndex = input.indexOf(STRING_QUOTE);
			endIndex = input.lastIndexOf(STRING_QUOTE);
				
			if(isOnlyOneQuote(startIndex,endIndex)){
				return input;
			} else {
				parseFreeInput_ = extractParseFreeInput(input, startIndex, endIndex);
				parseFreeString_ = extractParseFreeString(input, startIndex, endIndex);
				return parseFreeInput_;
			}			
		}
		
		return input;
	}

	public String replaceParseFree(String input){
		return input.replace(STRING_QUOTE + STRING_QUOTE, STRING_QUOTE + parseFreeString_ + STRING_QUOTE);
	}

	private String extractParseFreeString(String input, int start, int end) {
		return input.substring(start + INT_OFFSET,end);
	}

	private String extractParseFreeInput(String input, int start, int end) {	
		return input.substring(INT_ZERO, start + INT_OFFSET) + input.substring(end);
	}

	private boolean isOnlyOneQuote(int startIndex, int endIndex) {
		return (startIndex == endIndex);
	}
}
	// End of segment: C:\Users\Jireh\Documents\CS2103T_main\src\parser\ParseFreeManager.java





	/**
	 * origin: C:\Users\Jireh\Documents\CS2103T_main\src\parser\ParserFacade.java
	 */


public class ParserFacade {
	
	private static ParserFacade pf_ = new ParserFacade();
	
	private ParserFacade(){		
	}
	
	public static ParserFacade getInstance() {
		return pf_;
	}

	public Task getTask(String input){
		InputParser ip = new InputParser();
		ip.parseInput(input); 
		return new Task(ip.getTaskDescription(),ip.getStartDate(),ip.getStartTime(),ip.getEndDate(),ip.getEndTime(),ip.getDeadLine());
	}
	
	public String getCommandString(String input){
		CommandRetriever cr = CommandRetriever.getInstance();
		return cr.getCommandString(input);
	}
	
	public String getStringWithoutCommand(String input){
		CommandRetriever cr = CommandRetriever.getInstance();
		return input.replaceFirst(cr.getCommandString(input),"").trim();
	}
	
	public TentativeTask getTentative(String input){
		TentativeParser tp = TentativeParser.getInstance();
		return tp.parseTentative(input);
	}
	
}

	// End of segment: C:\Users\Jireh\Documents\CS2103T_main\src\parser\ParserFacade.java





	/**
	 * origin: C:\Users\Jireh\Documents\CS2103T_main\src\parser\TimeFormatter.java
	 */


public class TimeFormatter {
	
	private static final String[] DICTIONARY_NOON = {"NOON", "NN"};
	private static final String[] DICTIONARY_MIDNIGHT = {"MIDNIGHT", "MN"};
	private static final String[] DICTIONARY_MORNING = {"MORNING", "MORN"};
	private static final String[] DICTIONARY_AFTERNOON = {"AFTERNOON", "AFTN"};
	private static final String[] DICTIONARY_EVENING = {"EVENING"};
	private static final String[] DICTIONARY_NIGHT = {"TONIGHT", "NIGHTTIME", "NITE", "TONITE"};
	
	private static final String STRING_NOON = "1200";
	private static final String STRING_MIDNIGHT = "0000";
	private static final String STRING_MORNING = "1100";
	private static final String STRING_AFTERNOON = "1700";
	private static final String STRING_EVENING = "1900";
	private static final String STRING_NIGHT = "2300";
	
	private static final String STRING_DASH = "-";
	private static final String STRING_TO = "to";
	private static final String STRING_COLON = ":";
	
	
	public TimeFormatter(){
	}

	public String convertSPTformat(String time) {
		
		if(dictionaryContains(DICTIONARY_NOON, time)){
			return STRING_NOON;
		} else if (dictionaryContains(DICTIONARY_MIDNIGHT, time)){
			return STRING_MIDNIGHT;
		} else if (dictionaryContains(DICTIONARY_MORNING, time)){
			return STRING_MORNING;
		} else if (dictionaryContains(DICTIONARY_AFTERNOON, time)){
			return STRING_AFTERNOON;
		} else if (dictionaryContains(DICTIONARY_EVENING, time)){
			return STRING_EVENING;
		} else if (dictionaryContains(DICTIONARY_NIGHT, time)){
			return STRING_NIGHT;
		}
		System.out.println("fail");
		return time;
	}

	public String convertDTformat(String time) {
		
		String hours = null;
		String minutes = "00";
		
		try{
			Scanner sc = new Scanner(time).useDelimiter("[^0-9]+");		
			Integer integer = sc.nextInt();
			if(integer == 12){
				if(time.replace("12", "").equalsIgnoreCase("NN")){
					return STRING_NOON;
				}
				if(time.replace("12", "").equalsIgnoreCase("MN")){
					return STRING_MIDNIGHT;
				}
				if(time.contains("AM") || time.contains("am")){
					integer -= 12;
				}

			}

			if(time.contains("PM") || time.contains("pm") && integer < 12){
				integer += 12;
			}
			
			hours = integer.toString();
			
			if(sc.hasNextInt()){
				Integer temp = sc.nextInt();
				minutes = temp.toString();
			}

		} catch(Exception e){
			System.out.println("exception");
			return time;
		}

		if(hours.length() < 2){
			hours = "0" + hours;
		}
		return hours + minutes;
	}

	public String convertMTformat(String time) {

		String[] timeArray = time.split(STRING_COLON);
		
		if(timeArray[0].length() < 2){
			time = "0" + time;
		}
		
		return time.replace(STRING_COLON, "");
	}
	
	private boolean dictionaryContains(String[] dictionary, String keyword) {
		boolean isFound = false;
		for (int i = 0; i < dictionary.length; i++) {
			if (dictionary[i].equalsIgnoreCase(keyword)) {
				isFound = true;
				break;
			}
		}
		return isFound;
	}

	public String convertDTFformat(String time) {
		
		String hours = null;
		String minutes = "00";
		
		String[] timeArray = time.split(STRING_DASH);
		if(timeArray.length < 2){
			timeArray = time.split(STRING_TO);
		}
		
		try{
			Scanner sc = new Scanner(timeArray[0]).useDelimiter("[^0-9]+");		
			Integer integer = sc.nextInt();
			if(integer == 12){
				if(time.contains("AM") || time.contains("am")){
					integer -= 12;
				}
			}
			
			if(time.contains("PM") || time.contains("pm") && integer < 12){
				integer += 12;
			}
			
			hours = integer.toString();
			
			if(sc.hasNextInt()){
				Integer temp = sc.nextInt();
				minutes = temp.toString();
			}
			
		} catch(Exception e){
			System.out.println("exception");
			return null;
		}
		
		if(hours.length() < 2){
			hours = "0" + hours;
		}
		
		
		
		return hours + minutes;
	}

	public String convertDTNformat(String time) {
		
		String hours = null;
		String minutes = "00";
		
		String[] timeArray = time.split(STRING_DASH);
		if(timeArray.length < 2){
			timeArray = time.split(STRING_TO);
		}
		
		try{
			Scanner sc = new Scanner(timeArray[1]).useDelimiter("[^0-9]+");		
			Integer integer = sc.nextInt();
			if(integer == 12){
				if(time.contains("AM") || time.contains("am")){
					integer -= 12;
				}
			}
			
			if(time.contains("PM") || time.contains("pm") && integer < 12){
				integer += 12;
			}
			
			hours = integer.toString();
			
			if(sc.hasNextInt()){
				Integer temp = sc.nextInt();
				minutes = temp.toString();
			}
			
		} catch(Exception e){
			System.out.println("exception");
			return null;
		}
		
		if(hours.length() < 2){
			hours = "0" + hours;
		}

		return hours + minutes;
	}
}

	// End of segment: C:\Users\Jireh\Documents\CS2103T_main\src\parser\TimeFormatter.java





	/**
	 * origin: C:\Users\Jireh\Documents\CS2103T_main\src\parser\TimeParser.java
	 */


public class TimeParser {
	
	/**
	 * String constants
	 */
	private static final String STRING_SPACE = " ";
	private static final String STRING_COLON = ":";
	
	private static final String FORMAT_SPECIAL = "SPT ";
	private static final String FORMAT_DEFAULT = "DT ";
	private static final String FORMAT_MILITARY = "MT ";
	private static final String FORMAT_DASH_TIME_FIRST = "DTF ";
	private static final String FORMAT_DASH_TIME_NEXT = "DTN ";
	
	/**
	 * String Dictionaries
	 */
	private static final String[] DICTIONARY_SPECIAL_TIME = {"NOON", "NN",
															"MIDNIGHT", "MN",
															"MORNING", "MORN",
															"AFTERNOON", "AFTN",
															"TONIGHT", "NIGHTTIME", "NITE", "TONITE"};
	
	private static final String DASH_TIME_REGEX = "(1[012]|[1-9])((:|.)[0-5][0-9])?(\\s)?(-|to)(\\s)?(1[012]|[1-9])((:|.)[0-5][0-9])?(\\s)?(?i)(am|pm|mn|nn)";
	
	private String time_ = null;
	private String start_ = null;
	private String end_ = null;
	
	private DateAndTimeChecker checker = DateAndTimeChecker.getInstance();

	public TimeParser(){		
	}

	protected String parseTimeWithoutKeyword(String[] tokens, int i, String input){

		time_ = null;
		TimeStandardizer ts = new TimeStandardizer();

		if(isNotOutOfBounds(i, tokens.length)){

			if(dictionaryContains(DICTIONARY_SPECIAL_TIME, tokens[i])){
				time_ = tokens[i];
				input = input.replaceFirst(time_, "").trim();
				time_ = ts.formatTime(FORMAT_SPECIAL + time_);
			}

			if(tokens[i].contains("pm")|| tokens[i].contains("am") || tokens[i].contains("nn") || tokens[i].contains("mn")){
				if(checker.isValidDefaultTimeFormat(tokens[i])){
					time_ = tokens[i];
					input = input.replaceFirst(time_, "").trim();
					time_ = ts.formatTime(FORMAT_DEFAULT + time_);
				}
			}
			
			if(tokens[i].matches("([01]?[0-9]|2[0-3]):[0-5][0-9]")){
				if(checker.isValidMilitaryTimeFormat(tokens[i])){
					time_ = tokens[i];
					input = input.replaceFirst(time_, "").trim();
					time_ = ts.formatTime(FORMAT_MILITARY + time_);
				}

			}

//			if(tokens[i].replaceFirst(STRING_COLON, "").length() == 4){
//				if(checker.isValidMilitaryTimeFormat(tokens[i])){
//					time_ = tokens[i];
//					input = input.replaceFirst(time_, "").trim();
//					time_ = ts.formatTime(FORMAT_MILITARY + time_);
//				}
//			}

		}
		return input;
	}
	
	protected String parseDashTimeWithoutKeyword(String[] tokens, int i, String input){
		start_ = null;
		end_ = null;
		String toReplace = null;
		TimeStandardizer ts = new TimeStandardizer();
		
		if(isNotOutOfBounds(i+2, tokens.length)){
			String temp = tokens[i] + tokens[i+1] + tokens[i+2];
			if(temp.matches(DASH_TIME_REGEX)){
				toReplace = tokens[i] + STRING_SPACE + tokens[i+1] + STRING_SPACE + tokens[i+2];
				start_ = ts.formatTime(FORMAT_DASH_TIME_FIRST + temp);
				end_ = ts.formatTime(FORMAT_DASH_TIME_NEXT + temp);
				input = input.replaceFirst(toReplace, "");
			}
		}
		
		if(isNotOutOfBounds(i, tokens.length)){
			if(tokens[i].matches(DASH_TIME_REGEX)){
				start_ = ts.formatTime(FORMAT_DASH_TIME_FIRST + tokens[i]);
				end_ = ts.formatTime(FORMAT_DASH_TIME_NEXT + tokens[i]);
				input = input.replaceFirst(tokens[i], "");
			}
		}
		
		return input;
	}

	protected String parseTimeWithKeyword(String[] tokens, int i, String input) {
		
		time_ = null;
		TimeStandardizer ts = new TimeStandardizer();
		
		if(isNotOutOfBounds(i+1, tokens.length)){

			if(dictionaryContains(DICTIONARY_SPECIAL_TIME, tokens[i+1])){
				time_ = tokens[i+1];
				input = input.replaceFirst(tokens[i] + STRING_SPACE + time_, "").trim();
				time_ = ts.formatTime(FORMAT_SPECIAL + time_);
			}
			
			if(tokens[i+1].contains("pm")|| tokens[i+1].contains("am") || tokens[i+1].contains("nn") || tokens[i+1].contains("mn")){
				if(checker.isValidDefaultTimeFormat(tokens[i+1])){
					time_ = tokens[i+1];
					input = input.replaceFirst(tokens[i] + STRING_SPACE + time_, "").trim();
					time_ = ts.formatTime(FORMAT_DEFAULT + time_);
				}
			}
			
			if(tokens[i+1].matches("([01]?[0-9]|2[0-3]):[0-5][0-9]")){
				if(checker.isValidMilitaryTimeFormat(tokens[i+1])){
					time_ = tokens[i+1];
					input = input.replaceFirst(tokens[i] + STRING_SPACE + time_, "").trim();
					time_ = ts.formatTime(FORMAT_MILITARY + time_);
				}
			}
			
//			if(tokens[i+1].replaceFirst(STRING_COLON, "").length() == 4){
//				if(checker.isValidMilitaryTimeFormat(tokens[i+1])){
//					time_ = tokens[i+1];
//					input = input.replaceFirst(tokens[i] + STRING_SPACE + time_, "").trim();
//					time_ = ts.formatTime(FORMAT_MILITARY + time_);
//				}
//			}
		}
		
		return input;
	}
	
	protected String parseDashTimeWithKeyword(String[] tokens, int i, String input){
		start_ = null;
		end_ = null;
		String toReplace = null;
		TimeStandardizer ts = new TimeStandardizer();
		
		if(isNotOutOfBounds(i+3, tokens.length)){
			String temp = tokens[i+1] + tokens[i+2] + tokens[i+3];
			if(temp.matches(DASH_TIME_REGEX)){
				toReplace = tokens[i] + STRING_SPACE + tokens[i+1] + STRING_SPACE + tokens[i+2] + STRING_SPACE + tokens[i+3];
				start_ = ts.formatTime(FORMAT_DASH_TIME_FIRST + temp);
				end_ = ts.formatTime(FORMAT_DASH_TIME_NEXT + temp);
				input = input.replaceFirst(toReplace, "");
			}
		}
		
		if(isNotOutOfBounds(i+1, tokens.length)){
			if(tokens[i+1].matches(DASH_TIME_REGEX)){
				start_ = ts.formatTime(FORMAT_DASH_TIME_FIRST + tokens[i]);
				end_ = ts.formatTime(FORMAT_DASH_TIME_NEXT + tokens[i]);
				input = input.replaceFirst(tokens[i] + STRING_SPACE + tokens[i+1], "");
			}
		}
		
		return input;
	}


	protected String getTime() {
		return time_;
	}
	
	protected String getStart(){
		return start_;
	}
	
	protected String getEnd(){
		return end_;
	}
	
	private boolean isNotOutOfBounds(int index, int length) {
		return index < length && index >= 0;
	}

	private boolean dictionaryContains(String[] dictionary, String keyword) {
		boolean isFound = false;
		for (int i = 0; i < dictionary.length; i++) {
			if (dictionary[i].equalsIgnoreCase(keyword)) {
				isFound = true;
				break;
			}
		}
		return isFound;
	}
}

	// End of segment: C:\Users\Jireh\Documents\CS2103T_main\src\parser\TimeParser.java





	/**
	 * origin: C:\Users\Jireh\Documents\CS2103T_main\src\parser\TimeStandardizer.java
	 */


public class TimeStandardizer {

	/**
	 * String constants
	 */
	private final String STRING_SPACE = " ";


	private static enum FormatType {
		SPT, DT, MT, DTF, DTN, INVALID
	};

	private static final String FORMAT_SPECIAL = "SPT";
	private static final String FORMAT_DEFAULT = "DT";
	private static final String FORMAT_MILITARY = "MT";	
	private static final String FORMAT_DASH_TIME_FIRST = "DTF";
	private static final String FORMAT_DASH_TIME_NEXT = "DTN";

	public TimeStandardizer(){
	}

	public String formatTime(String time){

		String timeFormat = time.split(STRING_SPACE).clone()[0];
		time = time.replaceFirst(timeFormat, "").trim();
		FormatType formatType = getFormatType(timeFormat);
		System.out.println(timeFormat);
		TimeFormatter tf = new TimeFormatter();

		switch (formatType) {
		case SPT :
			//System.out.println("time Format: SPT");
			time = tf.convertSPTformat(time);
			break;
		case DT :
			//System.out.println("time Format: DT");
			time = tf.convertDTformat(time);
			break;
		case MT :
			//System.out.println("time Format: MT");
			time = tf.convertMTformat(time);
			break;
		case DTF :
			time = tf.convertDTFformat(time);
			break;
		case DTN :
			time = tf.convertDTNformat(time);
			break;
		case INVALID :
			System.out.print("Error");
			break;
		default :
			MyLogger.log(Level.SEVERE, "Fatal error has occured in TimeStandardizer!");
			assert true;
		}


		return time;
	}

	private static FormatType getFormatType(String format) {

		if (format.equalsIgnoreCase(FORMAT_SPECIAL)) {
			return FormatType.SPT;
		} else if (format.equalsIgnoreCase(FORMAT_DEFAULT)) {
			return FormatType.DT;
		} else if (format.equalsIgnoreCase(FORMAT_MILITARY)) {
			return FormatType.MT;
		} else if (format.equalsIgnoreCase(FORMAT_DASH_TIME_FIRST)) {
			return FormatType.DTF;
		} else if (format.equalsIgnoreCase(FORMAT_DASH_TIME_NEXT)) {
			return FormatType.DTN;
		} else {
			return FormatType.INVALID;
		}
	}
}



	// End of segment: C:\Users\Jireh\Documents\CS2103T_main\src\parser\TimeStandardizer.java





	/**
	 * origin: C:\Users\Jireh\Documents\CS2103T_main\src\test\TestParserFacade.java
	 */

public class TestParserFacade {

	private static final String TASK_STRING_FORMAT = "event: " + "%1$s" + "\n"
			+ "start date: " + "%2$s" + "\n" + "end date: " + "%3$s" + "\n"
			+ "start time: " + "%4$s" + "\n" + "end time: " + "%5$s" + "\n"
			+ "deadLine: " + "%6$s" + "\n"
			+ "is done: " + "%7$s" + "\n" + "is urgent: " + "%8$s" + "\n";
	ParserFacade parser = ParserFacade.getInstance(); 
	private Task task_;
	private static final String STRING_QUOTE = "\"";

	@Test
	public void testNormal() {
		//normal condition: adding task_ without date or time
		task_ = parser.getTask("add go to school");
		testParserOutput(String.format(TASK_STRING_FORMAT, "go to school", "null",
				"null", "null", "null","null", "false", "false"), taskStringRepresentation(task_));
	}

	@Test
	public void testNothing() {
		//adding nothing at all
		task_ = parser.getTask("");
		testParserOutput(String.format(TASK_STRING_FORMAT, "", "null",
				"null", "null", "null","null", "false", "false"), taskStringRepresentation(task_));
	}

	@Test
	public void testByForDate() {

		//testing using "by" keyword for date
		task_ = parser.getTask("add do homework by 21/12/2014");
		testParserOutput(String.format(TASK_STRING_FORMAT, "do homework", "null",
				"null", "null", "2359", "21/12/2014", "false", "false"), taskStringRepresentation(task_));

		task_ = parser.getTask("add do homework by 21 dec 2014");
		testParserOutput(String.format(TASK_STRING_FORMAT, "do homework", "null",
				"null", "null", "2359", "21/12/2014", "false", "false"), taskStringRepresentation(task_));

		task_ = parser.getTask("add do homework by 21 december 2014");
		testParserOutput(String.format(TASK_STRING_FORMAT, "do homework", "null",
				"null", "null", "2359", "21/12/2014", "false", "false"), taskStringRepresentation(task_));

		task_ = parser.getTask("add do homework by 21st dec 2014");
		testParserOutput(String.format(TASK_STRING_FORMAT, "do homework", "null",
				"null", "null", "2359", "21/12/2014", "false", "false"), taskStringRepresentation(task_));
	}

	@Test
	public void testByForTime() {

		//testing using "by" keyword for time
		task_ = parser.getTask("add do homework by 21/12/2014 2pm");
		testParserOutput(String.format(TASK_STRING_FORMAT, "do homework", "null",
				"null", "1400", "null","21/12/2014", "false", "false"), taskStringRepresentation(task_));

		task_ = parser.getTask("add do homework by 21/12/2014 2am");
		testParserOutput(String.format(TASK_STRING_FORMAT, "do homework", "null",
				"null", "0200", "null","21/12/2014", "false", "false"), taskStringRepresentation(task_));

		task_ = parser.getTask("add do homework by 21/12/2014 12am");
		testParserOutput(String.format(TASK_STRING_FORMAT, "do homework", "null",
				"null", "0000", "null","21/12/2014", "false", "false"), taskStringRepresentation(task_));

		task_ = parser.getTask("add do homework by 21/12/2014 12pm");
		testParserOutput(String.format(TASK_STRING_FORMAT, "do homework", "null",
				"null", "1200", "null","21/12/2014", "false", "false"), taskStringRepresentation(task_));
	}

	@Test
	public void testFromToDate() {

		//testing "from" and "to" for 2 date interval
		task_ = parser.getTask("add do homework from 21/12/2014 to 22/12/2014");
		testParserOutput(String.format(TASK_STRING_FORMAT, "do homework", "21/12/2014",
				"22/12/2014", "null", "null","null", "false", "false"), taskStringRepresentation(task_));

		task_ = parser.getTask("add do homework from 21 dec to 22/12/2014");
		testParserOutput(String.format(TASK_STRING_FORMAT, "do homework", "21/12/2014",
				"22/12/2014", "null", "null","null", "false", "false"), taskStringRepresentation(task_));

		task_ = parser.getTask("add do homework from 21/12/2014 to 22 dec");
		testParserOutput(String.format(TASK_STRING_FORMAT, "do homework", "21/12/2014",
				"22/12/2014", "null", "null","null", "false", "false"), taskStringRepresentation(task_));
	}

	@Test
	public void testFromToTime() {

		//testing "from" and "to" for 2 time interval
		task_ = parser.getTask("add do homework from 21/12/2014 2pm to 22/12/2014 3pm");
		testParserOutput(String.format(TASK_STRING_FORMAT, "do homework", "21/12/2014",
				"22/12/2014", "1400", "1500","null", "false", "false"), taskStringRepresentation(task_));

		task_ = parser.getTask("add do homework from 21 dec 2am to 22 dec 3am");
		testParserOutput(String.format(TASK_STRING_FORMAT, "do homework", "21/12/2014",
				"22/12/2014", "0200", "0300","null", "false", "false"), taskStringRepresentation(task_));

		task_ = parser.getTask("add do homework from 21 dec 2pm to 22 dec 3pm");
		testParserOutput(String.format(TASK_STRING_FORMAT, "do homework", "21/12/2014",
				"22/12/2014", "1400", "1500","null", "false", "false"), taskStringRepresentation(task_));

		task_ = parser.getTask("add do homework from 21st dec 2pm to 22nd dec 3pm");
		testParserOutput(String.format(TASK_STRING_FORMAT, "do homework", "21/12/2014",
				"22/12/2014", "1400", "1500","null", "false", "false"), taskStringRepresentation(task_));

		task_ = parser.getTask("add do homework from 21/12/2014 2pm to 22 dec 3pm");
		testParserOutput(String.format(TASK_STRING_FORMAT, "do homework", "21/12/2014",
				"22/12/2014", "1400", "1500","null", "false", "false"), taskStringRepresentation(task_));

		task_ = parser.getTask("add do homework from 21 dec 2pm to 22/12/2014 3pm");
		testParserOutput(String.format(TASK_STRING_FORMAT, "do homework", "21/12/2014",
				"22/12/2014", "1400", "1500","null", "false", "false"), taskStringRepresentation(task_));

		task_ = parser.getTask("add do homework from 21/12/2014 2pm to 22nd dec 3pm");
		testParserOutput(String.format(TASK_STRING_FORMAT, "do homework", "21/12/2014",
				"22/12/2014", "1400", "1500","null", "false", "false"), taskStringRepresentation(task_));

		task_ = parser.getTask("add do homework from 21st dec 2pm to 22/12/2014 3pm");
		testParserOutput(String.format(TASK_STRING_FORMAT, "do homework", "21/12/2014",
				"22/12/2014", "1400", "1500","null", "false", "false"), taskStringRepresentation(task_));
	}

	@Test
	public void testSpecial() {

		//testing special cases: quotes
		task_ = parser.getTask("add watch day after " + STRING_QUOTE + "tmr" + STRING_QUOTE + " by 21/12/2014");
		testParserOutput(String.format(TASK_STRING_FORMAT, "watch day after " + STRING_QUOTE + "tmr" + STRING_QUOTE, "null",
				"null", "null", "2359","21/12/2014", "false", "false"), taskStringRepresentation(task_));

		task_ = parser.getTask("add " + STRING_QUOTE + "watch day after tmr" + STRING_QUOTE + " by 21/12/2014");
		testParserOutput(String.format(TASK_STRING_FORMAT, STRING_QUOTE + "watch day after tmr" + STRING_QUOTE, "null",
				"null", "null", "2359","21/12/2014", "false", "false"), taskStringRepresentation(task_));

	}

	private void testParserOutput(String expected, String actual){
		assertEquals(expected, actual);
	}

	// return a string representation of the task_
	private String taskStringRepresentation(Task task_) {
		return String.format(TASK_STRING_FORMAT, task_.getTaskDescription(),
				task_.getStartDate(), task_.getEndDate(),
				task_.getStartTime(), task_.getEndTime(),task_.getDeadLine(),
				task_.isDone(), task_.isUrgent());
	}
}

	// End of segment: C:\Users\Jireh\Documents\CS2103T_main\src\test\TestParserFacade.java





